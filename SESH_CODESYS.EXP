

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Configuration' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MODBUS_CONFIGURATION        
VAR                                
END_VAR                            
(* @END_DECLARATION := '0' *)
(*                                 
   <?xml version="1.0" encoding="UTF-16" standalone="yes"?>
<network xml_structure_version="1">
	<generator_settings minRTUTaskCycleTimeMs="5" minEthaskCycleTimeMs="5" ethSlaveMultiplier="0.1" rtuInterfaceMultiplier="0.1" taskGeneration="true"/>
	<master_interface type="serial" name="Configuration Root Node" com_port="2" baudrate="19200" databits="8" stopbits="1" parity="even" hwtype="RS485" flow_control="Xon/Xoff" asciimode="false" expanded="true">
		<mb_slave comment="" name="ModbusSlave" expanded="true" type="generic">
			<mb_connection type="serial" unitid="1" request_delay_ms="0" response_timeout_ms="20"/>
			<generic_vars comment="" expanded="true">
				<generic_var data_type="INT">
					<generic_params name="dcCurrIn" comment="" expanded="true" mb_access="ro"/>
					<mb_address explicitAccess="false" FCRead="3" FCWrite="0" ReadMBAddress="4" WriteMBAddress="0" ReadBitOffset="0" WriteBitOffset="0"/>
				</generic_var>
			</generic_vars>
		</mb_slave>
	</master_interface>
</network>
                              
*)                                 
;                                  
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/External' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK GENSETCheck
VAR_INPUT
	DCBatteryVoltage: REAL;
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)


(*Check IF GENSET is already running . IF it is do nothing as battery voltage will increase just check if we need to turn it off*)
IF gv_isGenSetON THEN
	(* is batter voltage in a good range *)
	IF DCBatteryVoltage  >  gc_DCVoltageGenSetOFF THEN
		(*IF DC value is below thershold for more then X threshold seconds*)
		IF gc_DCGenCycleCount >= gv_DCGenCycleCount THEN
			(*t rigger dc generator OFF*)
			gv_isGenSetON := FALSE;
			gv_DCGenCycleCount := 0;
		ELSE
			gv_DCGenCycleCount := gv_DCGenCycleCount + 1;
		END_IF

	END_IF

(*check DC (battery) against threshold value to see if we need to turn on generator*)
ELSIF DCBatteryVoltage < gc_DCVoltageGenSetON THEN
		(*IF DC value is below thershold for more then X threshold seconds*)
		IF gv_DCGenCycleCount >= gc_DCGenCycleCount   THEN
			(*THEN trigger relay to fire GENSET*)
			(*t rigger dc generator OFF*)
			gv_isGenSetON:= TRUE;
			gv_DCGenCycleCount := 0;
		ELSE
			gv_DCGenCycleCount := gv_DCGenCycleCount + 1;
		END_IF

END_IF

gv_statusRELAY1 := gv_isGenSetON;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/External' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK ThresholdTrigger
VAR_INPUT

	DCBatteryVoltage          :REAL;
	ThresholdVoltageON    :REAL;
	ThresholdVoltageOFF  :REAL;
	Cycelcount                      :INT;
	CycelcountThres		  :INT;
	StateFlag				  :BOOL;


END_VAR
VAR_OUTPUT
		StateFlagOutput		         :BOOL;
		CycelcountOutput			  :INT;

END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)


(*Check IF GENSET is already running . IF it is do nothing as battery voltage will increase*)

IF StateFlag THEN
	(* is batter voltage in a good range *)
	IF DCBatteryVoltage  >  ThresholdVoltageOFF THEN
		(*IF DC value is below thershold for more then X threshold seconds*)
		IF CycelcountThres = Cycelcount THEN
			(*t rigger dc generator OFF*)
			StateFlag := FALSE;
			Cycelcount := 0;
		ELSE
			Cycelcount := Cycelcount + 1;
		END_IF

	END_IF

(*check DC (battery) against threshold value*)
ELSIF DCBatteryVoltage < ThresholdVoltageON THEN
		(*IF DC value is below thershold for more then X threshold seconds*)
		IF Cycelcount = CycelcountThres   THEN
			(*THEN trigger relay to fire GENSET*)
			(*t rigger dc generator OFF*)
			StateFlag:= TRUE;
			Cycelcount := 0;
		ELSE
			Cycelcount := Cycelcount + 1;
		END_IF

END_IF
CycelcountOutput := Cycelcount;
StateFlagOutput := StateFlag;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Generated Code\/Serial\/MBCFG' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MBCFG_COM_OBJECTS
VAR_INPUT

      MBCFG_MB_COM_2	:	MBCFG_COM_SER_OBJECT := (   ASCII_Mode      := FALSE,
                                                     COM_PORT        := 2,	 
                                                     COM_BAUDRATE    := BAUD_19200,
                                                     COM_PARITY      := PARITY_EVEN,
                                                     COM_STOPBITS    := STOPBITS_1,
                                                     COM_BYTESIZE    := BS_8,
                                                     COM_FLOW_CONTROL:= HALFDUPLEX,
                                                     TIME_OUT        := t#100ms
                                                 );



END_VAR
(* @END_DECLARATION := '0' *)
;
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Generated Code\/Serial' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MBCFG_ModbusSlave (* generated by config one prg for each slave *)

VAR_INPUT

END_VAR

VAR_OUTPUT
           dcCurrIn       :    INT;       (**)


    (*--- system variables (read only) -------------------------*)
    MBCFG_SlaveAddress  :   USINT := 1; (* valid range 1..247   *)
    MBCFG_TimeOut       :   TIME  := t#20ms;
    MBCFG_RequestDelay  :   TIME  := t#0ms; (* 0 means no delay *)
    MBCFG_Error         :   MBCFG_eERROR;
	MBCFG_SERCOM_ERROR  : 	BYTE; (* generated by sercomm.lib -> see documentation of sercomm.lib *)
    (*----------------------------------------------------------*)
END_VAR

{library private}
VAR CONSTANT
    zz_VARIABLECOUNT    :   INT := 1;   (* number of variables  *)
    zz_JOBCOUNT         :   INT := 1;   (* number of jobs       *)
END_VAR
VAR

    (*=== VARIABLE LIST ===============================================================================*)
    zz_VariableList :   ARRAY[1..zz_VARIABLECOUNT] OF MBCFG_typVARIABLE :=
        (   BitSize         := 16,
        ptVar           := 0,
        ReadJobIndex    := 1,
        ReadStartBitNo  := 0,
        WriteJobIndex   := 0,
        WriteStartBitNo := 0 )

                        ;
    (*=================================================================================================*)

    (*=== JOB LIST ====================================================================================*)
    zz_JobList      :   ARRAY[1..zz_JOBCOUNT] OF MBCFG_typCOM_JOB :=
         (   Functioncode            := 3,
        ReadStartAddress        := 4,
        ReadQuantity            := 1,
        WriteStartAddress       := 0,
        WriteQuantity           := 0,
        ptReadData              := 0, 
        ptWriteData             := 0 )

                        ;
    (*=================================================================================================*)

    (*### MODBUS MASTER ##### FIXED CODE ###########################################*)
    zz_MBCFG_MASTER			:	MBCFG_MASTER_SERIAL; (* for serial modbus RTU/ASCII *)
    (*##############################################################################*)

END_VAR
(* @END_DECLARATION := '0' *)
(*--- for each variable one entry ------------------------------------*)
   zz_VariableList[1].ptVar := ADR(dcCurrIn);

(*--------------------------------------------------------------------*)


(*=== call of the master for this slave ====================================================*)
zz_MBCFG_MASTER(   usiSlaveAddress  := MBCFG_SlaveAddress,               (* fixed entry     *)
                    tTimeOut        := MBCFG_TimeOut,                    (* fixed entry     *)
                    iVariableCount  := zz_VARIABLECOUNT,                 (* fixed entry     *)
                    ptVariableList  := ADR(zz_VariableList),             (* fixed entry     *)
                    iJobCount       := zz_JOBCOUNT,                      (* fixed entry     *)
                    ptJobList       := ADR(zz_JobList),                  (* fixed entry     *)
                    tRequestDelay   := MBCFG_RequestDelay,               (* fixed entry     *)
                    MB_ComObject    := MBCFG_COM_OBJECTS.MBCFG_MB_COM_2,(* generated entry *)
                    eError          => MBCFG_Error                       (* fixed entry     *)
                );
(*==========================================================================================*)

MBCFG_SERCOM_ERROR := MBCFG_COM_OBJECTS.MBCFG_MB_COM_2.bInterfaceError;
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Helpers' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION INC_TO_AMPERE : REAL
VAR_INPUT
	IN		:	WORD;
END_VAR

(* @END_DECLARATION := '0' *)
(* calculation from increments to ampere *)
INC_TO_AMPERE := (80.0 		(* max. current *)
                                       / 29126)	(* -> 32767 - 3641  Increments of the module for MAX_CURRENT *)
						* WORD_TO_INT(IN);
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Helpers' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION INC_TO_VOLT : REAL
VAR_INPUT
	IN		:	WORD;
END_VAR

VAR
	tempVal: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(* calculation from increments to ampere *)
tempVal := WORD_TO_REAL(IN);

(*divide according to *)
INC_TO_VOLT :=  IN * ( 30.0 / 32767.0);
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/POWER_MEASURMENT' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK POWER_MEASURMENT_DC
VAR_INPUT
	tCycleTime						: TIME:=t#1s;					(* Cycletime for reading values*)
END_VAR
VAR_OUTPUT
	DCV1 :REAL;
	DCV2 :REAL;

	DCPower1: REAL;
	DCPower2: REAL;

	DCCurr1 : REAL;
	DCCurr2 : REAL;

END_VAR
VAR
	TONInst : TON; (* Sleep timer  *)
	rDCVoltage1RAW  AT %IW60: WORD;
	rDCVoltage2RAW  AT %IW61 :WORD;

	rDCVoltage1: REAL;
	rDCVoltage2:REAL;

	dcCurrInRaw  : INT ;
	dcCurrOutRaw :INT;

	dcCurrIn:REAL;
	dcCurrOut:REAL;

	dcReadingError :INT;
END_VAR
(* @END_DECLARATION := '0' *)
TONInst( IN:= TRUE, PT := tCycleTime);

IF TONInst.Q THEN
	(* get sensor reading*)
	MBCFG_ModbusSlave(
		dcCurrIn=>dcCurrInRaw  );

	(* Do conversions from raw numbers to real values smooth with  avereging*)
	dcCurrIn :=  (dcCurrIn + INC_TO_AMPERE(dcCurrInRaw))/2;
	dcCurrOut := INC_TO_AMPERE(dcCurrInRaw);
	
	rDCVoltage1 := (rDCVoltage1 + INC_TO_VOLT(rDCVoltage1RAW))/2;
	rDCVoltage2:= INC_TO_VOLT(rDCVoltage2RAW);

	(* Power Calculations*)
	DCPower1 := (DCPower1 + (dcCurrIn * rDCVoltage1))/2;
	DCPower2 := (dcCurrOut * rDCVoltage2);

	
	DCV1 := rDCVoltage1;
	DCV2 := rDCVoltage2;

	DCCurr1 := dcCurrIn;
	DCCurr2 := dcCurrOut;
	
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Test_Functions' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM DC_TEST
VAR
	rDCVoltage1  AT %IW60: WORD;
	rDCVoltage2  AT %IW61 :WORD;
	DC1V: REAL;
	DC2V: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
DC1V :=0;
DC2V :=0;

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Test_Functions' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MYSQL_TEST
VAR

	xDoIt : BOOL;
	wState : WORD; (* Statemachine*)
	oMySql : MySql_Context; (* Used like Structure for keeping login and status information - Do not call it with in your program *)

	sample:BOOL;

	(* Functionblock to contact MySql server *)
	oMySqlLogin : MySql_Login;
	sHost : STRING :='youre_database';  (*'application.dyndns.info';*)
	uiPort : UINT := your_db_port;
	sUser : STRING := 'username;
	sPwd : STRING := 'password';
	sDB : STRING := 'DB';   	(* Optional - Name of database instance to connect to *)
	sTable:STRING := 'db_table';
	xConnect : BOOL := TRUE;
	diErrorLogin : DINT;
	sStatusLogin : STRING(500);
	xConnected : BOOL;
	iSiteCode: INT := 1000; (*1000 is code for Nyange this needs to be somehow made dynamic and unique for each site*)

END_VAR
(* @END_DECLARATION := '0' *)


(* Call function block "MySql_Login" every cycle to monitor connection status *)
oMySqlLogin(sHost:= sHost,
			uiPort:= uiPort,
			sUsername:= sUser,
			sPassword:= sPwd,
			sDatabase:= sDB,
			oMySql:= oMySql,
			xStart:= xConnect,
			diError=> diErrorLogin,
			sStatus=> sStatusLogin,
			xConnected=> xConnected);


IF xConnected THEN
	sample := TRUE;
	xDoIt := TRUE;
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Test_Functions' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PLC_PRG
VAR

	SERIAL_MODBUS_MASTER: MODBUS_MASTER_RTU;
	error: enumMB_ERROR;
	Query					:	typModbusQuery;
	Response				:	typModbusResponse;

	MODBUSCOM_AAN_UIT: BOOL;
	R_TRIG1: R_TRIG;
	start: BOOL;

	bCOM_PORT					:	BYTE					:=2 ; (*Port / module nummer*)
	cbBAUDRATE					:	COM_BAUDRATE 		:=BAUD_19200; (*Instelling IO Check*)
	cpPARITY						:	COM_PARITY 				:= PARITY_EVEN; (*Instelling IO Check*)
	csSTOPBITS					:	COM_STOPBITS 			:= STOPBITS_1; (*Instelling IO Check*)
	cbsBYTESIZE					:	COM_BYTESIZE 			:=BS_8 ; (*Instelling IO Check*)
	cfFLOW_CONTROL			:	COM_FLOW_CONTROL 	:= HALFDUPLEX ; (*Instelling IO Check*)


END_VAR
(* @END_DECLARATION := '0' *)
_FBD_BODY
_NETWORKS : 2
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
R_TRIG1
_BOX_EXPR : 1
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
MODBUSCOM_AAN_UIT
_OPERAND
_EXPRESSION
_NEGATIV
start
_EXPRESSION
_POSITIV
AND
_EXPRESSION
_POSITIV
R_TRIG
_OUTPUTS : 0
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_SET
start
_NETWORK

_COMMENT
''
_END_COMMENT
_ASSIGN
_FUNCTIONBLOCK
SERIAL_MODBUS_MASTER
_BOX_EXPR : 10
_OPERAND
_EXPRESSION
_POSITIV
bCOM_PORT
_OPERAND
_EXPRESSION
_POSITIV
cbBAUDRATE
_OPERAND
_EXPRESSION
_POSITIV
cpPARITY
_OPERAND
_EXPRESSION
_POSITIV
csSTOPBITS
_OPERAND
_EXPRESSION
_POSITIV
cbsBYTESIZE
_OPERAND
_EXPRESSION
_POSITIV
cfFLOW_CONTROL
_OPERAND
_EXPRESSION
_POSITIV
T#500ms
_OPERAND
_EXPRESSION
_POSITIV
start
_OPERAND
_EXPRESSION
_POSITIV
Query
_OPERAND
_EXPRESSION
_POSITIV
Response
_EXPRESSION
_POSITIV
MODBUS_MASTER_RTU
_OUTPUTS : 0
_EXPRESSION
_POSITIV
_OUTPUTS : 1
_OUTPUT
_POSITIV
_NO_SET
error

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Test_Functions' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM RELAY_TEST
VAR
	wState: BOOL :=FALSE;
	statusRELAY AT %QX60.0: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)


IF NOT wState THEN
		statusRELAY := TRUE;
ELSE
		statusRELAY := FALSE;
END_IF

IF wState THEN
		wState := FALSE;
ELSE
		wState := TRUE;
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Utils' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION Create_Data_Point : DataPoint
VAR
		arCurrDataPoint   : DataPoint;
END_VAR
VAR_INPUT

	iSiteCode: INT;
	rTotalApparentPower				: REAL;						(* Total Apparent Power													II Scheinleistung gesamt *)
	rTotalPowerFactorPF				: REAL;						(* Total Power Factor PF 													II Leistungsfaktor_PF gesamt *)

	arFrequency						: ARRAY[1..3] OF REAL;		(* Frequency																II Frequenz *)
	arVoltage_L_N					: ARRAY[1..3] OF REAL;		(* Voltage L-N 																II Spannung Lx N *)
	arCurrent							: ARRAY[1..3] OF REAL;		(* Current 															   		II Strom *)

	(* TODO add the time stamp into buffered items*)

	DCV1 :REAL;
	DCV2 :REAL;

	DCPower1: REAL;
	DCPower2: REAL;

	DCCurr1 : REAL;
	DCCurr2 : REAL;


END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
	arCurrDataPoint.iSiteCode := iSiteCode;
	arCurrDataPoint.rTotalApparentPower:=rTotalApparentPower;
	arCurrDataPoint.rTotalPowerFactorPF:=rTotalPowerFactorPF;

	arCurrDataPoint.arFrequency_1:=arFrequency[1];
	arCurrDataPoint.arVoltage_L_N_1:=arVoltage_L_N[1];
	arCurrDataPoint.arCurrent_1:=arCurrent[1];
	arCurrDataPoint.arPower_1:=arCurrDataPoint.arCurrent_1*arCurrDataPoint.arVoltage_L_N_1;

	arCurrDataPoint.arFrequency_2:=arFrequency[2];
	arCurrDataPoint.arVoltage_L_N_2:=arVoltage_L_N[2];
	arCurrDataPoint.arCurrent_2:=arCurrent[2];
	arCurrDataPoint.arPower_2:=arCurrDataPoint.arCurrent_2*arCurrDataPoint.arVoltage_L_N_2;


	arCurrDataPoint.arFrequency_3:=arFrequency[3];
	arCurrDataPoint.arVoltage_L_N_3:=arVoltage_L_N[3];
	arCurrDataPoint.arCurrent_3:=arCurrent[3];
	arCurrDataPoint.arPower_3:=arCurrDataPoint.arCurrent_3*arCurrDataPoint.arVoltage_L_N_3;

	arCurrDataPoint.timeStamp := Get_Time();

	arCurrDataPoint.DCV1 := DCV1;
	arCurrDataPoint.DCV2:=DCV2;
	arCurrDataPoint.DCPower1:=DCPower1;
	arCurrDataPoint.DCPower2:=DCPower2;
	arCurrDataPoint.DCCurr2:=DCCurr2;
	arCurrDataPoint.DCCurr2:=DCCurr2;


	Create_Data_Point := arCurrDataPoint;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Utils' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION Get_Time : STRING
VAR_INPUT

END_VAR
VAR
	TimeStamp: STRING;
	SystemTime: SysTime64;
	Time_date: SystemTimeDate;
	TimeDate: CurTimeEx;
	iHours:INT;
	iMinutes:INT;
	iSeconds: INT;
	iDay: INT;
	iMonth: INT;
	iYear: INT;

END_VAR

(* @END_DECLARATION := '0' *)
(* Haal de systeemtijd op *)
TimeDate(SystemTime:= SystemTime, TimeDate:= Time_date);

(* Sla uren en minuten apart op *)
iHours := Time_date.Hour;
iMinutes := Time_date.Minute;
iSeconds := Time_date.Second;
iDay := Time_date.Day;
iMonth := Time_date.Month;
iYear := Time_date.Year;

TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iYear));
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iMonth));
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iDay));
TimeStamp := CONCAT(TimeStamp,'T');
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iHours));
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iMinutes));
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iSeconds));
TimeStamp := CONCAT(TimeStamp,'Z');

(* return timestamp created *)
Get_Time := TimeStamp;




END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM Main_logger
VAR
	xDoIt : BOOL;
	wState : WORD; (* Statemachine*)
	oMySql : MySql_Context; (* Used like Structure for keeping login and status information - Do not call it with in your program *)


	(* working data points *)
	arCurrDataPoint : DataPoint;


	hasBufferedItems :  BOOL; (*Flag indicating the status of the buffer *)
	TONInst : TON; (* Sleep timer  *)


	(* Functionblock to contact MySql server *)
	oMySqlLogin : MySql_Login;

	xConnect : BOOL;
	diErrorLogin : DINT;
	sStatusLogin : STRING(500);
	xConnected : BOOL;


	(* Paremeters for 494 power measurement configuration *)
	xEnable							: BOOL:= TRUE;				(* Activates the function block 											II Aktivierung des Bausteins *)
	tCycleTime						: TIME:=t#1s;					(* Cycletime for reading values											II Zykluszeit für das Auslesen der Messwerte *)
	abIn_750_494 AT %IB72 : ARRAY [0..23] OF BYTE;
       abOut_750_494 AT %QB72:  ARRAY [0..23] OF BYTE;
	d750_494                               :  Fb_750_494_AC_Compact_01;  (* local function block instance*)

	(*Genset*)
	gensetINS :GENSETCheck;
	loadShedIns: ThresholdTrigger;
	genSetIns: ThresholdTrigger;

	(* Output DC variables *)
	dc_measure : POWER_MEASURMENT_DC;
	DCV1 :REAL;
	DCV2 :REAL;
	DCPower1: REAL;
	DCPower2: REAL;
	DCCurr1 : REAL;
	DCCurr2 : REAL;

	(* Output variables from 494 *)
      bToken							      : BYTE;
	xReady							: BOOL; 						(* Signal that the last read process is finished 							II Anzeige, dass der letzte Lesevorgang abgeschlossen ist*)
	rTotalActivePower					: REAL;						(* Tota lActive Power 														II Wirkleistung gesamt *)
	rTotalReactivePower				: REAL;						(* Total Reactive Power													II Blindleistung gesamt *)
	rTotalApparentPower				: REAL;						(* Total Apparent Power													II Scheinleistung gesamt *)
	rTotalPowerFactorPF				: REAL;						(* Total Power Factor PF 													II Leistungsfaktor_PF gesamt *)
	rTotalActiveEnergy				: REAL;						(* Total Active Energy	 													II Wirkenergie gesamt *)
	rTotalReactiveEnergy				: REAL;						(* Total Reactive Energy 													II Blindenergie gesamt *)
	rTotalApparentEnergy				: REAL;						(* Total Apparent Energy 													II Scheinenergie gesamt *)
	xRotatingField						: BOOL;						(* Rotating Field 															II Drehfeld rechts *)
	arFrequency						: ARRAY[1..3] OF REAL;		(* Frequency																II Frequenz *)
	arVoltage_L_N					: ARRAY[1..3] OF REAL;		(* Voltage L-N 																II Spannung Lx N *)
	arCurrent							: ARRAY[1..3] OF REAL;		(* Current 															   		II Strom *)
	arPower_L_N					: ARRAY[1..3] OF REAL;
	abFeedback						: ARRAY[1..8] OF BYTE;		(*	0   = no Error 															II kein Fehler
																			1   = Invalid values measure ID 										II Einträge MID nicht gültig
																			2   = Timeout
																			3   = Function block not active 										II Baustein nicht aktiv
																			4   = Settings process active (read/write) 							II Parameterbearbeitung aktiv (Lesen/Schreiben)
																			16  = Overflow Value 1
																			32  = Overflow Value 2
																			48  = Overflow Value 1 + Overflow Value 2
																			64  = Overflow Value 3
																			80  = Overflow Value 1 + Overflow Value 3
																			96  = Overflow Value 2 + Overflow Value 3
																			112 = Overflow Value 1 + Overflow Value 2 + Overflow Value 3
																			128 = Overflow Value 4
																			144 = Overflow Value 1 + Overflow Value 4
																			160 = Overflow Value 2 + Overflow Value 4
																			176 = Overflow Value 1 + Overflow Value 2 + Overflow Value 4
																			192 = Overflow Value 3 + Overflow Value 4
																			208 = Overflow Value 1 + Overflow Value 3 + Overflow Value 4
																			224 = Overflow Value 2 + Overflow Value 3 + Overflow Value 4
																			240 = Overflow Value 1 + Overflow Value 2 + Overflow Value 3 + Overflow Value 4*)



	(* Functionblock to process SQL statements who do not return result sets *)
	oMySqlExec1 : MySql_Execute;
	asSqlStatement1 : ARRAY [0..gcMySql_iSqlUpperBound] OF STRING(gcMySql_iSqlLength);
	xExec1 : BOOL;
	diErrorExec1 : DINT;
	sStatusExec1 : STRING(700);

	(*TODO clean this up these might be unnecassar delete if not used *)
	(* Functionblock to process SQL statements who return result sets *)
	oMySqlQuery1 : MySql_Query;
	asSqlQuery1 : ARRAY [0..gcMySql_iSqlUpperBound] OF STRING(gcMySql_iSqlLength);
	xQuery1 : BOOL;
	diErrorQuery1 : DINT;
	sStatusQuery1 : STRING(500);
	stQueryResult1 : MySql_ResultSet;


	(* Convert "stQueryResult" to IEC *)
	stTableData : TableData;
	row, col : INT;
	sValue: STRING(500); (* Returns the value of requested row and col as STRING *)
	dwResult: DWORD; (* Error code of function "MySql_Convert2IEC() *)
	xConvertError : BOOL;

	(* Functionblock to disconnect MySql server *)
	oMySqlLogout : MySql_Logout;
	xDisconnect : BOOL;
	diErrorLogout : DINT;
	sStatusLogout : STRING(500);

	(* Helpers *)
	iHelp : INT;
	i : INT;
	END_: BOOL;
	strTempSQLStatement: STRING(raw_SQL_STR_LENGTH);


	(* debug variables *)
	iCountExecFailed: INT;
	xDolt: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(*Get AC power data every cycle*)


d750_494 (						    xEnable:=xEnable,
										tCycleTime:=tCycleTime,
										abOut_750_494:=abOut_750_494,
										abIn_750_494:=abIn_750_494,
										bToken:=bToken,
										xReady=>xReady,
										rTotalActivePower=> rTotalActivePower,
										rTotalReactivePower=>rTotalReactivePower,
										rTotalApparentPower=>rTotalApparentPower,
										rTotalPowerFactorPF=>rTotalPowerFactorPF,
										rTotalActiveEnergy=>rTotalActiveEnergy,
										rTotalReactiveEnergy=>rTotalReactiveEnergy,
										rTotalApparentEnergy=>rTotalApparentEnergy,
										xRotatingField=>xRotatingField,
										arFrequency=>arFrequency,
										arVoltage_L_N=>arVoltage_L_N,
										arCurrent=>arCurrent,
										abFeedback=>abFeedback
										);


(*  Get DC measurement *)
dc_measure(
	tCycleTime:=tCycleTime,
	DCV1=> DCV1,
	DCV2=>DCV2,
	DCPower1=>DCPower1 ,
	DCPower2=>DCPower2,
	DCCurr1=>DCCurr1 ,
	DCCurr2=>DCCurr2 );

(*check genset situation*)
(*
gensetINS(DCBatteryVoltage:=DCV1);
*)
(*check battery voltage for genset trigger*)
loadShedIns(DCBatteryVoltage:=DCV1,
					ThresholdVoltageON:=gc_DCVoltageGenSetON,
					ThresholdVoltageOFF:=gc_DCVoltageGenSetOFF,
					Cycelcount:=gv_DCGenCycleCount,
					CycelcountThres:=gc_DCGenCycleCount,
					StateFlag:=gv_isGenSetON,
					StateFlagOutput=>gv_isGenSetON,
					CycelcountOutput=>gv_DCGenCycleCount
					);
(* fire off any relays if we need to *)
gv_statusRELAY1 := gv_isGenSetON;

(*check battery for load shedding *)
gensetINS(DCBatteryVoltage:=DCV1,
					ThresholdVoltageON := gc_LoadSheddingVoltageON,
					ThresholdVoltageOFF := gc_LoadSheddingVoltageOFF,
					Cycelcount :=	gv_DCLoadCycleCount,
					CycelcountThres := gc_DCLoadCycleCount,
					StateFlag  :=  gv_isLoadShedON,
					StateFlagOutput  =>  gv_isLoadShedON,
					CycelcountOutput  =>  gv_DCLoadCycleCount
					);
gv_statusRELAY1 := gv_statusRELAY1;

(* Call function block "MySql_Login" every cycle to monitor connection status *)

oMySqlLogin(sHost:= gc_sHost,
			uiPort:= gc_uiPort,
			sUsername:= gc_sUser,
			sPassword:= gc_sPwd,
			sDatabase:=gc_sDB,
			oMySql:= oMySql,
			xStart:= xConnect,
			diError=> diErrorLogin,
			sStatus=> sStatusLogin,
			xConnected=> xConnected);



CASE wState OF
0:

	xConnect := TRUE;
	wState := 10;

10:
	IF xConnected THEN

		xConnect := FALSE;
		IF xRotatingField  THEN  (*  Check that our power measurment model  is ready *)
			wState := 20; (* Proceede to execute SQL*)
		ELSE
			(* this is a different error state *)
			wState:= 45; (* wait and go to holding pattern for power measurement sensor to be ready*)
		END_IF
	ELSE
		wstate:=0;
	END_IF

20: (* prepare sql statement *)
	(*Create data point object to pass around *)
	IF hasBufferedItems THEN
		arCurrDataPoint := gv_Buffer[gv_iBuffPointer];
	ELSE
		arCurrDataPoint := Create_Data_Point (
													iSiteCode:=gc_iSiteCode,
													rTotalApparentPower:=rTotalApparentPower,
													rTotalPowerFactorPF:=rTotalPowerFactorPF,
													arFrequency:=arFrequency,
													arVoltage_L_N:=arVoltage_L_N,
													arCurrent:=arCurrent,
													DCV1 :=DCV1,
													DCV2 :=DCV2,
													DCPower1:= DCPower1,
													DCPower2:= DCPower2,
													DCCurr1 := DCCurr1,
													DCCurr2 :=DCCurr2);
	END_IF
	(* Create AC Statment *)
	asSqlStatement1  := SQLStatement(       toLog     := arCurrDataPoint,
												s_Table:= gc_sTable,
											);


	xExec1 := TRUE; (* Execute SQL-Insert-Statement *)
	wState :=25;

25:
	oMySqlExec1(asSqlCommand:=asSqlStatement1,
					oMySql:=oMySql,
					xStart:=xExec1,
					diError=> diErrorExec1,
					sStatus=>sStatusExec1);

	IF NOT  xExec1 THEN
		(* success *)
			xDisconnect := TRUE;
			wState := 46  (*finished go and disconnect or start again *);
		IF diErrorExec1 = 0 THEN
			IF hasBufferedItems THEN
				IF gv_iBuffCounter = gv_iBuffPointer THEN
					(*Buffer has been cleared reset counters*)
					gv_iBuffCounter := 0;
					gv_iBuffPointer := 0;
					hasBufferedItems := FALSE;
				ELSE
					gv_iBuffPointer := gv_iBuffPointer + 1; (*item pushed was buffered increment pointer *)
				END_IF
			END_IF
		ELSE
			(* Failed *)
			iCountExecFailed := iCountExecFailed +1; (* TODO count number of failures and fire an alarm *)
			wState:=45;
		END_IF
	END_IF


45: (* Wait here to debug convert problem *)
	(* buffer current value into memory *)
	IF gv_iBuffCounter < gc_MaxBufferSize THEN
		gv_Buffer[gv_iBuffCounter] := arCurrDataPoint; (* add data point to our buffer *)
		gv_iBuffCounter := gv_iBuffCounter + 1; (* incremenr buffer counter *)
		hasBufferedItems := TRUE; (*Flag indicating the status of the buffer *)
	END_IF
	wState := 46; (*move onto sleep*)

(*sleep X amount of time and continue*)
46:
	TONInst( IN:= TRUE, PT := gc_LogInterval);

	IF TONInst.Q THEN
			wState := 0;
		(* do nothing just wait*)
	END_IF

50: (* Disconnect from database *)
	oMySqlLogout(oMySql:= oMySql,
				 xStart:= xDisconnect,
				 diError=> diErrorLogout,
				 sStatus=> sStatusLogout);
	IF NOT xDisconnect THEN
		xDoIt := FALSE;
		wState := 0;
	END_IF
END_CASE


END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION SQLStatement : ARRAY [0..gcMySql_iSqlUpperBound] OF STRING(gcMySql_iSqlLength)
VAR_INPUT

	toLog:  DataPoint;
	s_Table : STRING;

END_VAR
VAR
	rTotalActivePower					: REAL;						(* Tota lActive Power 														II Wirkleistung gesamt *)
	rTotalReactivePower				: REAL;						(* Total Reactive Power													II Blindleistung gesamt *)
	rTotalApparentPower				: REAL;						(* Total Apparent Power													II Scheinleistung gesamt *)
	rTotalPowerFactorPF				: REAL;						(* Total Power Factor PF 													II Leistungsfaktor_PF gesamt *)
	rTotalActiveEnergy				: REAL;						(* Total Active Energy	 													II Wirkenergie gesamt *)
	rTotalReactiveEnergy				: REAL;						(* Total Reactive Energy 													II Blindenergie gesamt *)
	rTotalApparentEnergy				: REAL;						(* Total Apparent Energy 													II Scheinenergie gesamt *)
	xRotatingField						: BOOL;						(* Rotating Field 															II Drehfeld rechts *)
	arFrequency						: ARRAY[1..3] OF REAL;		(* Frequency																II Frequenz *)
	arVoltage_L_N					: ARRAY[1..3] OF REAL;		(* Voltage L-N 																II Spannung Lx N *)
	arCurrent							: ARRAY[1..3] OF REAL;		(* Current 															   		II Strom *)
	arPower							: ARRAY[1..3] OF REAL;		(* AC Power *)
	DCV1 :REAL;
	DCV2 :REAL;

	DCPower1: REAL;
	DCPower2: REAL;

	DCCurr1 : REAL;
	DCCurr2 : REAL;

	iSiteCode: INT;

END_VAR
(* @END_DECLARATION := '0' *)

iSiteCode := toLog.iSiteCode;

		(*DC measurement data send *)
		DCV1 := toLog.DCV1 ;
		DCV2 := toLog.DCV2;

		DCPower1:=  toLog.DCPower1;
		DCPower2:=  toLog.DCPower2;
	
		DCCurr1 :=toLog.DCCurr1 ;
		DCCurr2 := toLog.DCCurr2;

		(*AC Daat point *)
		(*TODO time stamp needs to be added if buffered data *)
		rTotalApparentPower := toLog.rTotalApparentPower;
		rTotalPowerFactorPF := toLog.rTotalPowerFactorPF;

		arFrequency[1] := toLog.arFrequency_1;
		arVoltage_L_N[1] := toLog.arVoltage_L_N_1;
		arCurrent[1] := toLog.arCurrent_1;
  	       arPower[1] := toLog.arPower_1;

		arFrequency[2] := toLog.arFrequency_2;
		arVoltage_L_N[2] := toLog.arVoltage_L_N_2;
		arCurrent[2] := toLog.arCurrent_2;
		arPower[2] := toLog.arPower_2;

		arFrequency[3] := toLog.arFrequency_3;
		arVoltage_L_N[3] := toLog.arVoltage_L_N_3;
		arCurrent[3] := toLog.arCurrent_3;
		arPower[3] := toLog.arPower_3;

		SQLStatement[0] := 'INSERT INTO ';
		SQLStatement[1] := s_Table;
		SQLStatement[2] :=  ' (rTotalApparentPower, rTotalPowerFactorPF, arFrequency1 , arFrequency2 ,arFrequency3,arVoltage_L_N1,arVoltage_L_N2, arVoltage_L_N3, arCurrent1,arCurrent2,arCurrent3,DCVolt1,DCVolt2,DCCurr1,DCCurr2 ,DCPower1,DCPower2,iSiteCode,acPower1,acPower2,acPower3)  VALUES ( ';
		(* AC Values *)

		SQLStatement[3] :=  CONCAT(REAL_TO_STRING(rTotalApparentPower), ',');
		SQLStatement[4] :=  CONCAT(REAL_TO_STRING(rTotalPowerFactorPF), ',');

		SQLStatement[5] :=  CONCAT(REAL_TO_STRING(arFrequency[1]), ',');
		SQLStatement[6] :=  CONCAT(REAL_TO_STRING(arFrequency[2]), ',');
		SQLStatement[7] :=  CONCAT(REAL_TO_STRING(arFrequency[3]), ',');

		SQLStatement[8] :=  CONCAT(REAL_TO_STRING( arVoltage_L_N[1] ), ',');
		SQLStatement[9] :=  CONCAT(REAL_TO_STRING( arVoltage_L_N[2] ), ',');
		SQLStatement[10] :=  CONCAT(REAL_TO_STRING( arVoltage_L_N[3] ), ',');

		SQLStatement[11] :=  CONCAT(REAL_TO_STRING(arCurrent[1] ), ',');
		SQLStatement[12] :=  CONCAT(REAL_TO_STRING(arCurrent[2]), ',');
		SQLStatement[13] :=  CONCAT(REAL_TO_STRING(arCurrent[3]), ',');

		(*  DC Values *)
		SQLStatement[14] :=  CONCAT(REAL_TO_STRING(DCV1), ',');
		SQLStatement[15] :=  CONCAT(REAL_TO_STRING(DCV2), ',');

		SQLStatement[16] :=  CONCAT(REAL_TO_STRING(DCCurr2), ',');
		SQLStatement[17] :=  CONCAT(REAL_TO_STRING(DCCurr2), ',');

		SQLStatement[18] :=  CONCAT(REAL_TO_STRING(DCPower1), ',');
		SQLStatement[19] :=  CONCAT(REAL_TO_STRING(DCPower1), ',');


		SQLStatement[20] :=  CONCAT(INT_TO_STRING(iSiteCode), ' ,' );
		SQLStatement[21] :=  CONCAT(REAL_TO_STRING(arPower[1] ), ',');
		SQLStatement[22] :=  CONCAT(REAL_TO_STRING(arPower[2]), ',');
		(* TODO add in load shedding and  genset values*)

		SQLStatement[23] :=  CONCAT(REAL_TO_STRING(arPower[3]), ')');



END_FUNCTION

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE DataPoint :
	STRUCT
		(*Common variables*)
		iSiteCode:INT;
		timeStamp: STRING;

		(*AC Variables*)
		(*
		rTotalActivePower:REAL;
		rTotalReactivePower:REAL;
		*)
		rTotalApparentPower:REAL;
		rTotalPowerFactorPF:REAL;
		(*
		rTotalActiveEnergy:REAL;
		rTotalReactiveEnergy:REAL;
		rTotalApparentEnergy:REAL;
		xRotatingField:BOOL;
		*)
		(*Line one*)
		arFrequency_1:REAL;
		arVoltage_L_N_1:REAL;
		arCurrent_1:REAL;
		arPower_1:REAL;
		(*Line two*)
		arFrequency_2:REAL;
		arVoltage_L_N_2:REAL;
		arCurrent_2:REAL;
		arPower_2:REAL;
		(*Line three*)
		arFrequency_3:REAL;
		arVoltage_L_N_3:REAL;
		arCurrent_3:REAL;
		arPower_3:REAL;

		(* DC Variables *)
		DCV1 :REAL;
		DCV2 :REAL;
		DCPower1: REAL;
		DCPower2: REAL;
		DCCurr1 : REAL;
		DCCurr2 : REAL;


		END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE RowData :
  STRUCT
  	dtDt 		: DT; 		(* Table field "timestamp" 	- MySql_Datatype "datetime" 	*)
  	asString 	: ARRAY [0..9] OF STRING(255);	(* Table fields "s0"-"s9" MySql_Datatype "varchar(255)" 	*)
  END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE TableData :
  STRUCT
	xValid : BOOL;
	iRowCount : INT;
	astRow : ARRAY [0..gcMySql_dwMaxRowCount] OF RowData;
  END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE typCSV :
STRUCT
	sDescription	:STRING;
	Parameter		:ARRAY[1..gc_ParameterCount] OF REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Global_Variables' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL

	gv_sFilePath: STRING;
	gv_iBuffCounter			:INT := 0; (* counter for  buffer*)
	gv_iBuffPointer			:INT := 0; (* pointer  for  buffer*)
	gv_Buffer					:ARRAY[0..gc_MaxBufferSize] OF DataPoint; (*In memory buffer of failed message attempts*)
	gv_isGenSetON                 :BOOL := FALSE;
	gv_isLoadShedON            :BOOL := FALSE;
	gv_DCGenCycleCount     : INT :=0 ;
	gv_DCLoadCycleCount     : INT :=0 ;
	gv_statusRELAY1 AT %QX60.0: BOOL; (*use for genset*)
	gv_statusRELAY2 AT %QX60.1: BOOL; (*use fore load shedding *)

END_VAR
VAR_GLOBAL CONSTANT

	(* Site specific variables*)
	gc_iSiteCode: INT := 1000; (*1000 is code for Nyange this needs to be somehow made dynamic and unique for each site*)


	MAX_ROWS : WORD := 30; (* Array size for converted table data *)

	gcMySql_iSqlUpperBound: INT := 29; (* Defines the upper bound of "asSqlStatement",
				used by function blocks "MySql_ExecSql" and "MySql_Query" 
				to provide an SQL statement as "ARRAY [0..UpperBound] OF STRING(Size)".
	*)

	gcMySql_iSqlLength: INT := 370; (* Defines the size in byte of an array element
				of "asSqlStatement", used by function blocks "MySql_ExecSql" and "MySql_Query" 
				to provide an SQL statement as "ARRAY [0..UpperBound] OF STRING(Size)".
	*)
	raw_SQL_STR_LENGTH: INT := 350;

	(* MYSQL configs *)
	(* MYSQL configs  dummy *)

	gc_sHost : STRING := '### your mysql server address here';  (*'application.dyndns.info';*)
	gc_uiPort : UINT := 3306;
	gc_sUser : STRING := '### your mysql server username ';
	gc_sPwd : STRING := '### your mysql password';
	gc_sDB : STRING := '### your MYSQL database';   	(* Optional - Name of database instance to connect to *)
	gc_sTable:STRING := '### your MYSql table' ;


	(* CSV Writing/Logging parameters*)
	gc_xWriteToSD: BOOL := TRUE;

	iMaxParams			:INT:=5;(* Number of Parameters per File *)
	gc_ParameterCount	:INT:=1;(* Number of Values per Parameter *)
	gc_RawDataSize		:UINT:=500; (* Raw data size for reading in file ASCII *)
	gc_MaxBufferSize 	       :INT := 5000; (*number of items to hold in memory*)
	gc_sFileName		: STRING := 'buffer.csv'; (* Working Filename   Complete path + filename *)

	(* Logging constants*)
	gc_LogInterval             :TIME := T#1s;
	gc_iTotalParams		:INT := 18;

	(* generator constants*)
	gc_DCVoltageGenSetON :REAL := 22; (*make this a bit higher tha load shedding time*)
	gc_DCVoltageGenSetOFF :REAL := 25; (*make this estimate soc %80*)

	(*how many cycles do we wait before we trigger the genset need to calculate based no cycletime *gc_DCGenCycleCount = total_seconds  *)
	gc_DCGenCycleCount       :INT := 40;

	(* load shedding paramters Load shedding will shut off loads when the batter falls below a certain voltage*)
	gc_LoadSheddingVoltageON  :INT := 22;
	gc_LoadSheddingVoltageOFF  :INT := 24;

	gc_DCLoadCycleCount       :INT := 40;


END_VAR

(* @OBJECT_END := 'Global_Variables' *)
(* @CONNECTIONS := Global_Variables
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Variable_Configuration' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_CONFIG
END_VAR

(* @OBJECT_END := 'Variable_Configuration' *)
(* @CONNECTIONS := Variable_Configuration
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)


_ALARMCONFIG
_ALARMCONFIGNEXTTEXTID : 10002
_ALARMCONFIGFORMATS : 'HH$':$'mm$':$'ss','dd$'-$'MM$'-$'yyyy'
_ALARMCLASSLIST : 1
_ALARMCLASSID : 0
_ALARMCLASSACKTYPE : 0
_ALARMCLASSNAME : 'DEFAULT'
_ALARMCLASSDESCRIPTION : ''
_ALARMCLASSBGCOLORS : 16777215,16777215,16777215
_ALARMCLASSTEXTCOLORS : 3394560,255,16711680
_ALARMCLASSBITMAPS : '','',''
_ALARMACTIONLIST : 0
(* @ALARMCLASSRESETCOLORS := '_ALARMCLASSRESETCOLORS: 33023,16777215' *)
(* @ALARMCLASSRESETBITMAP := '_ALARMCLASSRESETBITMAP: $'$'' *)
_ALARMGROUPLISTNAME : 'System'
_ALARMGROUPPATH : 'System'
_ALARMGROUPLIST : 0
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0

(* @ALARMCONFIGFLAGS := '_ALARMCONFIGFLAGS: 4' *)
(* @ALARMCONFIGGLOBALDB_STR := '_ALARMCONFIGGLOBALDB_STRINGS: $'$',$'$',$'$',$'$'' *)
(* @ALARMCONFIGGLOBALDB_NUM := '_ALARMCONFIGGLOBALDB_NUMBERS: 0,0' *)
_END_ALARMCONFIG


LIBRARY
C:\Program Files (x86)\WAGO Software\CoDeSys V2.3\Targets\WAGO\Libraries\POWER_MEASUREMENT\PowerMeasurement_494_02.lib 7.10.15 13:30:30
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 27
Fb_750_494_AC_Compact_01: 2048
Fb_750_494_AC_Values: 2048
Fb_750_494_AC_Values.GetMultiplicator: 2048
Fb_750_494_Configuration: 2048
Fb_750_494_Configuration.GetCommand: 2048
Fb_750_494_Configuration.GetMultiplicator: 2048
Fb_750_494_Configuration.GetParamValue: 2048
Fb_750_494_Configuration.GetRegisterValue: 2048
Fb_750_494_Configuration.ParamChannelCommRead: 2048
Fb_750_494_Configuration.ParamChannelCommWrite: 2048
Fb_750_494_Configuration.ProcessParamValues: 2048
Fb_750_494_Configuration.ProcessRegValues: 2048
Fb_750_494_Configuration.RegisterCommRead: 2048
Fb_750_494_Configuration.RegisterCommWrite: 2048
Fb_750_494_Configuration.SendCommand: 2048
Fb_750_494_Configuration.SynchronizeUI: 2048
Fb_750_494_DC_Values: 2048
Fb_750_494_DC_Values.GetMultiplicator: 2048
Fb_750_494_Harmonic_Values: 2048
Fb_750_494_Harmonic_Values.GetMultiplicator: 2048
Fb_750_494_State: 2048
Fu494ScaleValue: 2048
Func_750_494_Collection007Context: 2048
Func_750_494_Collection009Context: 2048
Func_750_494_CollectionXXXContext: 2048
Func_750_494_ConfigConsistency: 2048
FuVersion_750_494: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
Iecsfc.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 1
SFCActionControl: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
mod_com.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 11
ADD_PI_INFORMATION: 0
CRC16: 0
FBUS_ERROR_INFORMATION: 0
GET_DIGITAL_INPUT_OFFSET: 0
GET_DIGITAL_OUTPUT_OFFSET: 0
KBUS_ERROR_INFORMATION: 0
MOD_COM_VERSION: 0
PI_INFORMATION: 0
SET_DIGITAL_INPUT_OFFSET: 0
SET_DIGITAL_OUTPUT_OFFSET: 0
SLAVE_ADDRESS: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
Modb_l05.lib 22.4.13 12:50:12
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 21
ASCII_TO_RTU: 2048
MB_CRC: 2048
MB_HEX_TO_BYTE: 0
MODBUS_EXTENDED_MASTER: 2048
MODBUS_EXTENDED_MASTER_RTU: 2048
MODBUS_EXTENDED_SLAVE: 0
MODBUS_EXTENDED_SLAVE.MB_ACTION_LOOPBACK: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_READ_DISCRETE_INPUTS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_READ_INPUT_REGISTERS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_READ_WRITE_MULTIPLE_REGISTERS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_MASK_REGISTER: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_MULTIPLE_COILS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_MULTIPLE_REGISTERS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_SINGLE_COIL: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_SINGLE_REGISTER: 2048
MODBUS_MASTER_RTU: 0
MODBUSMASTER_RTU: 2048
MODBUSMASTER_RTU_EN: 2048
MODBUSSLAVE_RTU: 8
RTU_TO_ASCII: 2048
Version_Modb_l05: 2048
NumOfGVLs: 1
Global_Constants: 2048
END_LIBRARY

LIBRARY
SerComm.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 2
SERCOMM: 0
SERCOMM_VERSION: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
Serial_Interface_01.lib 22.4.13 12:50:14
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 7
SERIAL_COM_OBJECT: 2048
SERIAL_INTERFACE: 2048
SERIAL_INTERFACE.CLOSE_PORT: 2048
SERIAL_INTERFACE.OPEN_PORT: 2048
SERIAL_INTERFACE.RECEIVE_DATA: 2048
SERIAL_INTERFACE.SEND_DATA: 2048
Version_SerialInterface: 2048
NumOfGVLs: 1
Globale_InterfaceConstant: 0
END_LIBRARY

LIBRARY
Standard.lib 20.5.14 08:13:26
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 26
ASCIIBYTE_TO_STRING: 2048
CONCAT: 0
CTD: 0
CTU: 0
CTUD: 0
DELETE: 0
F_TRIG: 0
FIND: 0
INSERT: 0
LEFT: 0
LEN: 0
MID: 0
R_TRIG: 0
REAL_STATE: 2048
REPLACE: 0
RIGHT: 0
RS: 0
RTC: 0
SEMA: 0
SR: 0
STANDARD_VERSION: 2048
STRING_COMPARE: 2048
STRING_TO_ASCIIBYTE: 2048
TOF: 0
TON: 0
TP: 0
NumOfGVLs: 1
'Global Variables 0': 0
END_LIBRARY

LIBRARY
SYSLIBCALLBACK.LIB 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 2
SysCallbackRegister: 0
SysCallbackUnregister: 0
NumOfGVLs: 2
Globale_Variablen: 0
Version: 0
END_LIBRARY

LIBRARY
SysLibFile.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 12
SysFileClose: 0
SysFileCopy: 0
SysFileDelete: 0
SysFileEOF: 0
SysFileGetPos: 0
SysFileGetSize: 0
SysFileGetTime: 0
SysFileOpen: 0
SysFileRead: 0
SysFileRename: 0
SysFileSetPos: 0
SysFileWrite: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
SysLibSem.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 5
SysSemCreate: 0
SysSemDelete: 0
SysSemEnter: 0
SysSemLeave: 0
SysSemTry: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
SysLibSockets.lib 22.5.14 16:16:32
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 26
SysSockAccept: 0
SysSockBind: 0
SysSockClose: 0
SysSockConnect: 0
SysSockCreate: 0
SysSockGetHostByName: 0
SysSockGetHostName: 0
SysSockGetLastError: 2048
SysSockGetLastErrorSync: 2048
SysSockGetOption: 0
SysSockHtonl: 0
SysSockHtons: 0
SysSockInetAddr: 0
SysSockInetNtoa: 0
SysSockIoctl: 0
SysSockListen: 0
SysSockNtohl: 0
SysSockNtohs: 0
SysSockRecv: 0
SysSockRecvFrom: 0
SysSockSelect: 0
SysSockSend: 0
SysSockSendTo: 0
SysSockSetIPAddress: 0
SysSockSetOption: 0
SysSockShutdown: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
SysLibTime.lib 16.5.13 14:00:48
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 2
CurTime: 0
CurTimeEx: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
Wago_MBCFG_COMMON_01.lib 5.12.13 11:10:18
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 0
NumOfGVLs: 0
END_LIBRARY

LIBRARY
Wago_MBCFG_SERIAL_01.lib 17.9.14 14:24:36
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 2
MBCFG_COM_SER_OBJECT: 2048
MBCFG_MASTER_SERIAL: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
WagoLibMySQL_03.lib 23.7.14 09:13:36
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 9
MySql_Close: 2048
MySql_Context: 2048
MySql_Execute: 2048
MySql_GetStringValue: 2048
MySql_Login: 2048
MySql_Logout: 2048
MySql_Query: 2048
MySql_Scramble: 2048
MySql_Version: 2048
NumOfGVLs: 1
Global_Variables: 2048
END_LIBRARY

LIBRARY
WagoLibSHA1.lib 19.9.11 08:14:42
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 8
SHA1: 2048
SHA1Hex2String: 2048
SHA1Input: 2048
SHA1PadMessage: 2048
SHA1ProcessMessageBlock: 2048
SHA1Reset: 2048
SHA1Result: 2048
SHA1Version: 2048
NumOfGVLs: 1
Globale_Variablen: 2048
END_LIBRARY

PLC_CONFIGURATION
_GLOBAL
_VERSION: 3
_AUTOADR: 1
_CHECKADR: 0
_SAVECONFIGFILESINPROJECT: 1
_END_GLOBAL

_MODULE: '3S'
_SECTION_NAME: 'Root'
_INDEX_IN_PARENT: '-1'
_MODULE_NAME: 'PLC Configuration'
_NODE_ID: -1
_IECIN: %IB0
_IECOUT: %QB0
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_MODULE: '3S'
_SECTION_NAME: 'K_Bus'
_INDEX_IN_PARENT: '1'
_MODULE_NAME: 'K-Bus'
_NODE_ID: 0
_IECIN: %IB0
_IECOUT: %QB0
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: 'PFC200 CS 2ETH RS (FW03-...)'

_PARAMETER
_PARAM 201019000: 0, '1'
_PARAM 201019001: 0, '10000'
_PARAM 201019002: 0, '0'
_PARAM 201019003: 0, '1'
_END_PARAMETER

_MODULE: '3S'
_SECTION_NAME: 'Type_30_1_Channels'
_INDEX_IN_PARENT: '1'
_MODULE_NAME: '0750-0652#24 RS-232/RS-485 Interface adjustable (24 Bytes)'
_NODE_ID: 0
_IECIN: %IB120
_IECOUT: %QB120
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'BYTEOnB_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'I'
_IECADR: %IB0
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'BYTEOnB_Q'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'Q'
_IECADR: %QB0
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_30_1_Channels'
_INDEX_IN_PARENT: '2'
_MODULE_NAME: '0750-0652#24 RS-232/RS-485 Interface adjustable (24 Bytes)'
_NODE_ID: 1
_IECIN: %IB120
_IECOUT: %QB120
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'BYTEOnB_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'I'
_IECADR: %IB24
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'BYTEOnB_Q'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'Q'
_IECADR: %QB24
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_30_1_Channels'
_INDEX_IN_PARENT: '3'
_MODULE_NAME: '0750-0652#24 RS-232/RS-485 Interface adjustable (24 Bytes)'
_NODE_ID: 2
_IECIN: %IB144
_IECOUT: %QB144
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'BYTEOnB_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'I'
_IECADR: %IB48
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'BYTEOnB_Q'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'Q'
_IECADR: %QB48
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_58_1_Channels'
_INDEX_IN_PARENT: '4'
_MODULE_NAME: '0750-0494 3-phase PoM480/ 1A'
_NODE_ID: 3
_IECIN: %IB168
_IECOUT: %QB168
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word'
_CHANNEL_MODE: 'I'
_IECADR: %IW36
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 1'
_CHANNEL_MODE: 'I'
_IECADR: %IW37
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '3'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 2'
_CHANNEL_MODE: 'I'
_IECADR: %IW38
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '4'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 3'
_CHANNEL_MODE: 'I'
_IECADR: %IW39
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '5'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 1'
_CHANNEL_MODE: 'I'
_IECADR: %ID20
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '6'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 2'
_CHANNEL_MODE: 'I'
_IECADR: %ID21
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '7'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 3'
_CHANNEL_MODE: 'I'
_IECADR: %ID22
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '8'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 4'
_CHANNEL_MODE: 'I'
_IECADR: %ID23
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '9'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word'
_CHANNEL_MODE: 'Q'
_IECADR: %QW36
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '10'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 1'
_CHANNEL_MODE: 'Q'
_IECADR: %QW37
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '11'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 2'
_CHANNEL_MODE: 'Q'
_IECADR: %QW38
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '12'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 3'
_CHANNEL_MODE: 'Q'
_IECADR: %QW39
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_58_1_Channels'
_INDEX_IN_PARENT: '5'
_MODULE_NAME: '0750-0494 3-phase PoM480/ 1A'
_NODE_ID: 4
_IECIN: %IB192
_IECOUT: %QB192
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word'
_CHANNEL_MODE: 'I'
_IECADR: %IW48
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 1'
_CHANNEL_MODE: 'I'
_IECADR: %IW49
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '3'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 2'
_CHANNEL_MODE: 'I'
_IECADR: %IW50
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '4'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 3'
_CHANNEL_MODE: 'I'
_IECADR: %IW51
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '5'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 1'
_CHANNEL_MODE: 'I'
_IECADR: %ID26
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '6'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 2'
_CHANNEL_MODE: 'I'
_IECADR: %ID27
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '7'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 3'
_CHANNEL_MODE: 'I'
_IECADR: %ID28
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '8'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 4'
_CHANNEL_MODE: 'I'
_IECADR: %ID29
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '9'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word'
_CHANNEL_MODE: 'Q'
_IECADR: %QW48
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '10'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 1'
_CHANNEL_MODE: 'Q'
_IECADR: %QW49
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '11'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 2'
_CHANNEL_MODE: 'Q'
_IECADR: %QW50
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '12'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 3'
_CHANNEL_MODE: 'Q'
_IECADR: %QW51
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_8_2_Channels'
_INDEX_IN_PARENT: '6'
_MODULE_NAME: '0750-0483 2 AI 0-30V DC Differential Measurement Input'
_NODE_ID: 5
_IECIN: %IB216
_IECOUT: %QB216
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'Ch_1 Input word'
_CHANNEL_MODE: 'I'
_IECADR: %IW60
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'Ch_2 Input word'
_CHANNEL_MODE: 'I'
_IECADR: %IW61
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_10_2_Channels'
_INDEX_IN_PARENT: '7'
_MODULE_NAME: '0750-0513/0000-0001 2 DO 250V AC 2.0A Rel 2NO (PotFree)'
_NODE_ID: 6
_IECIN: %IB124
_IECOUT: %QB120
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'BOOLOnX_Q'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'Ch_1 Digital output'
_CHANNEL_MODE: 'Q'
_IECADR: %QX60.0
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'BOOLOnX_Q'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'Ch_2 Digital output'
_CHANNEL_MODE: 'Q'
_IECADR: %QX60.1
_END_CHANNEL
_END_MODULE
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'PFC200MODBUS'
_INDEX_IN_PARENT: '2'
_MODULE_NAME: 'Modbus variables'
_NODE_ID: 1
_IECIN: %IB0
_IECOUT: %QB0
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_PARAMETER
_PARAM 2010330101: 0, '1'
_PARAM 2010330102: 0, '1'
_PARAM 2010330201: 0, '1'
_PARAM 2010330202: 0, '502'
_PARAM 2010330203: 0, '600'
_PARAM 2010330301: 0, '1'
_PARAM 2010330302: 0, '502'
_PARAM 2010330401: 0, '0'
_PARAM 2010330402: 0, '1'
_PARAM 2010330403: 0, '5000'
_PARAM 2010330404: 0, '0'
_PARAM 2010330405: 0, '115200'
_PARAM 2010330406: 0, '1'
_PARAM 2010330407: 0, '1'
_PARAM 2010330408: 0, '0'
_PARAM 2010330409: 0, '0'
_END_PARAMETER
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'MB_MASTER'
_INDEX_IN_PARENT: '3'
_MODULE_NAME: 'Modbus-Master'
_NODE_ID: 2
_IECIN: %IB0
_IECOUT: %QB0
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''
_END_MODULE
_END_MODULE
PLC_END


RESOURCE

TASK MYSQL_Logging (PRIORITY := 29, INTERVAL := T#1s0ms);
Main_logger();
{Additional_info : 1,0,60000,0,1,4294967295}
END_TASK

TASK MB_RTU_MASTER_TASK (PRIORITY := 30, INTERVAL := T#5ms);
MBCFG_ModbusSlave();
{Additional_info : 1,0,0,0,1,4294967295}
END_TASK
{event_task : 'start','Called when program starts','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,1,11952}
{event_task : 'stop','Called when program stops','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,2,11952}
{event_task : 'before_reset','Called before reset takes place','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,3,11952}
{event_task : 'after_reset','Called after reset took place','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,4,11952}
{event_task : 'shutdown','Called before shutdown is performed','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,5,11952}
{event_task : 'excpt_watchdog','Software watchdog OF IEC-task expired','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,7,11952}
{event_task : 'excpt_access_violation','Access violation','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,12,11952}
{event_task : 'excpt_dividebyzero','Division BY zero','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,18,11952}
{event_task : 'after_reading_inputs','Called after reading of inputs','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,28,11952}
{event_task : 'before_writing_outputs','Called before writing of outputs','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,29,11952}
{event_task : 'debug_loop','Debug loop at breakpoint','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,31,11952}
{event_task : 'online_change','Is called after CodeInit() at Online-Change','','FUNCTION systemevent: DWORD VAR_INPUT dwEvent: DWORD; dwFilter: DWORD; dwOwner: DWORD; END_VAR '}{event_task_info : 0,33,11952}
{event_task : 'before_download','Is called before the Download starts','','FUNCTION systemevent: DWORD VAR_INPUT dwEvent: DWORD; dwFilter: DWORD; dwOwner: DWORD; END_VAR '}{event_task_info : 0,34,11952}

END_RESOURCE


_WORKSPACE
_GLOBALVISUALSETTINGS
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0
_VISUALBITMAPLISTCOUNT : 0
_END_GLOBALVISUALSETTINGS
_END_WORKSPACE
