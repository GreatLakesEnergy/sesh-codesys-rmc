

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Configuration' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MODBUS_CONFIGURATION        
VAR                                
END_VAR                            
(* @END_DECLARATION := '0' *)
(*                                 
   <?xml version="1.0" encoding="UTF-16" standalone="yes"?>
<network xml_structure_version="1">
	<generator_settings minRTUTaskCycleTimeMs="5" minEthaskCycleTimeMs="5" ethSlaveMultiplier="0.1" rtuInterfaceMultiplier="0.1" taskGeneration="true"/>
	<master_interface type="serial" name="Configuration Root Node" com_port="2" baudrate="19200" databits="8" stopbits="1" parity="even" hwtype="RS485" flow_control="Xon/Xoff" asciimode="false" expanded="true">
		<mb_slave comment="" name="ModbusSlave" expanded="true" type="generic">
			<mb_connection type="serial" unitid="1" request_delay_ms="0" response_timeout_ms="20"/>
			<generic_vars comment="" expanded="true">
				<generic_var data_type="INT">
					<generic_params name="dcCurrIn" comment="" expanded="true" mb_access="ro"/>
					<mb_address explicitAccess="false" FCRead="3" FCWrite="0" ReadMBAddress="4" WriteMBAddress="0" ReadBitOffset="0" WriteBitOffset="0"/>
				</generic_var>
			</generic_vars>
		</mb_slave>
	</master_interface>
</network>
                              
*)                                 
;                                  
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/External' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK GENSETCheck
VAR_INPUT

	DCBatteryVoltage: REAL;
END_VAR
VAR_OUTPUT
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)


(*Check IF GENSET is already running . IF it is do nothing as battery voltage will increase*)

IF gv_isGenSetON THEN
	(* is batter voltage in a good range *)
	IF DCBatteryVoltage  >  gc_DCVoltageGenSetOFF THEN
		(*IF DC value is below thershold for more then X threshold seconds*)
		IF gc_DCGenCycleCount > gv_DCGenCycleCount THEN
			(*t rigger dc generator OFF*)
			gv_isGenSetON := FALSE;
			gv_DCGenCycleCount := 0;
		ELSE
			gv_DCGenCycleCount := gv_DCGenCycleCount + 1;
		END_IF

	END_IF

(*check DC (battery) against threshold value*)
ELSIF DCBatteryVoltage < gc_DCVoltageGenSetON THEN
		(*IF DC value is below thershold for more then X threshold seconds*)
		IF gc_DCGenCycleCount > gv_DCGenCycleCount THEN
			(*THEN trigger relay to fire GENSET*)
			(*t rigger dc generator OFF*)
			gv_isGenSetON:= TRUE;
			gv_DCGenCycleCount := 0;
		ELSE
			gv_DCGenCycleCount := gv_DCGenCycleCount + 1;
		END_IF

END_IF


END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Generated Code\/Serial\/MBCFG' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MBCFG_COM_OBJECTS
VAR_INPUT

      MBCFG_MB_COM_2	:	MBCFG_COM_SER_OBJECT := (   ASCII_Mode      := FALSE,
                                                     COM_PORT        := 2,	 
                                                     COM_BAUDRATE    := BAUD_19200,
                                                     COM_PARITY      := PARITY_EVEN,
                                                     COM_STOPBITS    := STOPBITS_1,
                                                     COM_BYTESIZE    := BS_8,
                                                     COM_FLOW_CONTROL:= HALFDUPLEX,
                                                     TIME_OUT        := t#100ms
                                                 );



END_VAR
(* @END_DECLARATION := '0' *)
;
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Generated Code\/Serial' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MBCFG_ModbusSlave (* generated by config one prg for each slave *)

VAR_INPUT

END_VAR

VAR_OUTPUT
           dcCurrIn       :    INT;       (**) 


    (*--- system variables (read only) -------------------------*)
    MBCFG_SlaveAddress  :   USINT := 1; (* valid range 1..247   *)
    MBCFG_TimeOut       :   TIME  := t#20ms;
    MBCFG_RequestDelay  :   TIME  := t#0ms; (* 0 means no delay *)
    MBCFG_Error         :   MBCFG_eERROR;
	MBCFG_SERCOM_ERROR  : 	BYTE; (* generated by sercomm.lib -> see documentation of sercomm.lib *)
    (*----------------------------------------------------------*)
END_VAR

{library private}
VAR CONSTANT
    zz_VARIABLECOUNT    :   INT := 1;   (* number of variables  *)
    zz_JOBCOUNT         :   INT := 1;   (* number of jobs       *)
END_VAR
VAR

    (*=== VARIABLE LIST ===============================================================================*)
    zz_VariableList :   ARRAY[1..zz_VARIABLECOUNT] OF MBCFG_typVARIABLE :=
        (   BitSize         := 16,
        ptVar           := 0,
        ReadJobIndex    := 1,
        ReadStartBitNo  := 0,
        WriteJobIndex   := 0,
        WriteStartBitNo := 0 )

                        ;
    (*=================================================================================================*)

    (*=== JOB LIST ====================================================================================*)
    zz_JobList      :   ARRAY[1..zz_JOBCOUNT] OF MBCFG_typCOM_JOB :=
         (   Functioncode            := 3,
        ReadStartAddress        := 4,
        ReadQuantity            := 1,
        WriteStartAddress       := 0,
        WriteQuantity           := 0,
        ptReadData              := 0, 
        ptWriteData             := 0 )

                        ;
    (*=================================================================================================*)

    (*### MODBUS MASTER ##### FIXED CODE ###########################################*)
    zz_MBCFG_MASTER			:	MBCFG_MASTER_SERIAL; (* for serial modbus RTU/ASCII *)
    (*##############################################################################*)

END_VAR
(* @END_DECLARATION := '0' *)
(*--- for each variable one entry ------------------------------------*)
   zz_VariableList[1].ptVar := ADR(dcCurrIn);

(*--------------------------------------------------------------------*)


(*=== call of the master for this slave ====================================================*)
zz_MBCFG_MASTER(   usiSlaveAddress  := MBCFG_SlaveAddress,               (* fixed entry     *)
                    tTimeOut        := MBCFG_TimeOut,                    (* fixed entry     *)
                    iVariableCount  := zz_VARIABLECOUNT,                 (* fixed entry     *)
                    ptVariableList  := ADR(zz_VariableList),             (* fixed entry     *)
                    iJobCount       := zz_JOBCOUNT,                      (* fixed entry     *)
                    ptJobList       := ADR(zz_JobList),                  (* fixed entry     *)
                    tRequestDelay   := MBCFG_RequestDelay,               (* fixed entry     *)
                    MB_ComObject    := MBCFG_COM_OBJECTS.MBCFG_MB_COM_2,(* generated entry *)
                    eError          => MBCFG_Error                       (* fixed entry     *)
                );
(*==========================================================================================*)

MBCFG_SERCOM_ERROR := MBCFG_COM_OBJECTS.MBCFG_MB_COM_2.bInterfaceError;
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Helpers' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION INC_TO_AMPERE : REAL
VAR_INPUT
	IN		:	WORD;
END_VAR

(* @END_DECLARATION := '0' *)
(* calculation from increments to ampere *)
INC_TO_AMPERE := (80.0 		(* max. current *)
                                       / 29126)	(* -> 32767 - 3641  Increments of the module for MAX_CURRENT *)
						* WORD_TO_INT(IN);
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Helpers' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION INC_TO_VOLT : REAL
VAR_INPUT
	IN		:	WORD;
END_VAR

VAR
	tempVal: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
(* calculation from increments to ampere *)
tempVal := WORD_TO_REAL(IN);

(*divide according to *)
INC_TO_VOLT :=  IN * ( 30.0 / 32767.0);
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/POWER_MEASURMENT' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM POWER_MEASUREMENT_AC
VAR
	Typ_750_494_State: typ_750_494_State;
	abIn_750_494 AT %IB72 : ARRAY [0..23] OF BYTE;
       abOut_750_494 AT %QB72:  ARRAY [0..23] OF BYTE;
	bToken: BYTE;
	POWER_MEASURE: Fb_750_494_AC_Compact_01;

END_VAR
VAR_OUTPUT
	totalPower: REAL;
	totalReactivePower: REAL;
	totalApparentPower: REAL;
	rotatingField: BOOL;
	totalPowerFactor: REAL;
	totalActiveEnergy: REAL;
	totalReactiveEnergy: REAL;
	totalApparentEnergy: REAL;
	arCurrent: ARRAY [1..3] OF REAL;
	arVoltage: ARRAY [1..3] OF REAL;
	arFrequency: ARRAY [1..3] OF REAL;
	isPowerReady: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
_CFC_BODY
_ELEMENT
_ID: 7
_MACROID: -1
_POS: 25, 8
_TYPE: _INPUT
_TEXT: TRUE
_NEGATE: 0
_CONNECTOR: 
_END
_ELEMENT
_ID: 6
_MACROID: -1
_POS: 25, 6
_TYPE: _BOX
_INSTANCE: 1
_INSTANCENAME: POWER_MEASURE
_TYPENAME: Fb_750_494_AC_Compact_01
_ENENO: 0
_INPUTS: 7
_IN
_INPUTID: 7
_INPUTIDX: 0
_NEGATE: 0
_END
_IN
_INPUTID: 0
_INPUTIDX: 0
_NEGATE: 0
_END
_IN
_INPUTID: 0
_INPUTIDX: 0
_NEGATE: 0
_END
_IN
_INPUTID: 10
_INPUTIDX: 0
_NEGATE: 0
_END
_IN
_INPUTID: 11
_INPUTIDX: 0
_NEGATE: 0
_END
_IN
_INPUTID: 12
_INPUTIDX: 0
_NEGATE: 0
_END
_IN
_INPUTID: 13
_INPUTIDX: 0
_NEGATE: 0
_END
_OUTPUTS: 24
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_OUT
_NEGATE: 0
_CONNECTOR: 
_END
_PARAMETERS: 0
_END
_ELEMENT
_ID: 45
_MACROID: -1
_POS: 42, 8
_TYPE: _OUTPUT
_TEXT: isPowerReady
_INPUTID: 6
_INPUTIDX: 0
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 32
_MACROID: -1
_POS: 43, 9
_TYPE: _OUTPUT
_TEXT: totalPower
_INPUTID: 6
_INPUTIDX: 1
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 10
_MACROID: -1
_POS: 25, 11
_TYPE: _INPUT
_TEXT: Typ_750_494_State
_NEGATE: 0
_CONNECTOR: 
_END
_ELEMENT
_ID: 11
_MACROID: -1
_POS: 25, 12
_TYPE: _INPUT
_TEXT: abIn_750_494
_NEGATE: 0
_CONNECTOR: 
_END
_ELEMENT
_ID: 12
_MACROID: -1
_POS: 25, 13
_TYPE: _INPUT
_TEXT: abOut_750_494
_NEGATE: 0
_CONNECTOR: 
_END
_ELEMENT
_ID: 13
_MACROID: -1
_POS: 25, 14
_TYPE: _INPUT
_TEXT: bToken
_NEGATE: 0
_CONNECTOR: 
_END
_ELEMENT
_ID: 34
_MACROID: -1
_POS: 44, 10
_TYPE: _OUTPUT
_TEXT: totalReactivePower
_INPUTID: 6
_INPUTIDX: 2
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 35
_MACROID: -1
_POS: 43, 11
_TYPE: _OUTPUT
_TEXT: totalApparentPower
_INPUTID: 6
_INPUTIDX: 3
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 36
_MACROID: -1
_POS: 46, 12
_TYPE: _OUTPUT
_TEXT: totalPowerFactor
_INPUTID: 6
_INPUTIDX: 4
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 37
_MACROID: -1
_POS: 47, 13
_TYPE: _OUTPUT
_TEXT: totalActiveEnergy
_INPUTID: 6
_INPUTIDX: 5
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 38
_MACROID: -1
_POS: 48, 14
_TYPE: _OUTPUT
_TEXT: totalReactiveEnergy
_INPUTID: 6
_INPUTIDX: 6
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 39
_MACROID: -1
_POS: 49, 15
_TYPE: _OUTPUT
_TEXT: totalApparentEnergy
_INPUTID: 6
_INPUTIDX: 7
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 40
_MACROID: -1
_POS: 50, 16
_TYPE: _OUTPUT
_TEXT: rotatingField
_INPUTID: 6
_INPUTIDX: 8
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 41
_MACROID: -1
_POS: 51, 17
_TYPE: _OUTPUT
_TEXT: arCurrent
_INPUTID: 6
_INPUTIDX: 9
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 42
_MACROID: -1
_POS: 52, 18
_TYPE: _OUTPUT
_TEXT: arVoltage
_INPUTID: 6
_INPUTIDX: 11
_NEGATE: 0
_SETRESET: _NONE
_END
_ELEMENT
_ID: 43
_MACROID: -1
_POS: 53, 19
_TYPE: _OUTPUT
_TEXT: arFrequency
_INPUTID: 6
_INPUTIDX: 19
_NEGATE: 0
_SETRESET: _NONE
_END

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/POWER_MEASURMENT' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK POWER_MEASURMENT_DC
VAR_INPUT
	tCycleTime						: TIME:=t#1s;					(* Cycletime for reading values*)
END_VAR
VAR_OUTPUT
	DCV1 :REAL;
	DCV2 :REAL;

	DCPower1: REAL;
	DCPower2: REAL;

	DCCurr1 : REAL;
	DCCurr2 : REAL;

END_VAR
VAR
	TONInst : TON; (* Sleep timer  *)
	rDCVoltage1RAW  AT %IW60: WORD;
	rDCVoltage2RAW  AT %IW61 :WORD;

	rDCVoltage1: REAL;
	rDCVoltage2:REAL;

	dcCurrInRaw : INT;
	dcCurrOutRaw :INT;

	dcCurrIn:REAL;
	dcCurrOut:REAL;

	dcReadingError :INT;
END_VAR
(* @END_DECLARATION := '0' *)
TONInst( IN:= TRUE, PT := tCycleTime);

IF TONInst.Q THEN
	(* get sensor reading*)
	MBCFG_ModbusSlave(
		dcCurrIn=>dcCurrInRaw  );
	
	(* Do conversions from raw numbers to real values*)
	dcCurrIn := INC_TO_AMPERE(dcCurrInRaw);
	dcCurrOut := INC_TO_AMPERE(dcCurrInRaw);
	
	rDCVoltage1 := INC_TO_VOLT(rDCVoltage1RAW);
	rDCVoltage2:= INC_TO_VOLT(rDCVoltage2RAW);
	
	(* Power Calculations*)
	DCPower1 := (dcCurrIn * rDCVoltage1);
	DCPower2 := (dcCurrOut * rDCVoltage2);
	
	
	DCV1 := rDCVoltage1;
	DCV2 := rDCVoltage2;

	DCCurr1 := dcCurrIn;
	DCCurr2 := dcCurrOut;
	
END_IF
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Test_Functions' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM DC_TEST
VAR
	rDCVoltage1  AT %IW60: WORD;
	rDCVoltage2  AT %IW61 :WORD;
	DC1V: REAL;
	DC2V: REAL;
END_VAR
(* @END_DECLARATION := '0' *)
DC1V :=0;
DC2V :=0;

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Test_Functions' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MYSQL_TEST
VAR

	xDoIt : BOOL;
	wState : WORD; (* Statemachine*)
	oMySql : MySql_Context; (* Used like Structure for keeping login and status information - Do not call it with in your program *)

	sample:BOOL;

	(* Functionblock to contact MySql server *)
	oMySqlLogin : MySql_Login;
	sHost : STRING := 'sesh-dev1.cloudapp.net';  (*'application.dyndns.info';*)
	uiPort : UINT := 3306;
	sUser : STRING := 'wago1';
	sPwd : STRING := 'gle12345';
	sDB : STRING := 'sesh_DB';   	(* Optional - Name of database instance to connect to *)
	sTable:STRING := 'AC_POWER';
	xConnect : BOOL := TRUE;
	diErrorLogin : DINT;
	sStatusLogin : STRING(500);
	xConnected : BOOL;
	iSiteCode: INT := 1000; (*1000 is code for Nyange this needs to be somehow made dynamic and unique for each site*)

END_VAR
(* @END_DECLARATION := '0' *)


(* Call function block "MySql_Login" every cycle to monitor connection status *)
oMySqlLogin(sHost:= sHost,
			uiPort:= uiPort,
			sUsername:= sUser,
			sPassword:= sPwd,
			sDatabase:= sDB,
			oMySql:= oMySql,
			xStart:= xConnect,
			diError=> diErrorLogin,
			sStatus=> sStatusLogin,
			xConnected=> xConnected);


IF xConnected THEN
	sample := TRUE;
	xDoIt := TRUE;
END_IF

END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Test_Functions' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PLC_PRG
VAR
	rDCVoltage1 : ARRAY [0..23] OF BYTE;
	rDCVoltage2 : ARRAY [0..23] OF BYTE;
END_VAR
(* @END_DECLARATION := '0' *)
DC_TEST();
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Utils' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION Create_Data_Point : DataPoint
VAR
		arCurrDataPoint   : DataPoint;
END_VAR
VAR_INPUT

	iSiteCode: INT;
	rTotalActivePower					: REAL;						(* Tota lActive Power 														II Wirkleistung gesamt *)
	rTotalReactivePower				: REAL;						(* Total Reactive Power													II Blindleistung gesamt *)
	rTotalApparentPower				: REAL;						(* Total Apparent Power													II Scheinleistung gesamt *)
	rTotalPowerFactorPF				: REAL;						(* Total Power Factor PF 													II Leistungsfaktor_PF gesamt *)
	rTotalActiveEnergy				: REAL;						(* Total Active Energy	 													II Wirkenergie gesamt *)
	rTotalReactiveEnergy				: REAL;						(* Total Reactive Energy 													II Blindenergie gesamt *)
	rTotalApparentEnergy				: REAL;						(* Total Apparent Energy 													II Scheinenergie gesamt *)
	xRotatingField						: BOOL;						(* Rotating Field 															II Drehfeld rechts *)
	arFrequency						: ARRAY[1..3] OF REAL;		(* Frequency																II Frequenz *)
	arVoltage_L_N					: ARRAY[1..3] OF REAL;		(* Voltage L-N 																II Spannung Lx N *)
	arCurrent							: ARRAY[1..3] OF REAL;		(* Current 															   		II Strom *)

	(* TODO add the time stamp into buffered items*)

	DCV1 :REAL;
	DCV2 :REAL;

	DCPower1: REAL;
	DCPower2: REAL;

	DCCurr1 : REAL;
	DCCurr2 : REAL;


END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
	arCurrDataPoint.iSiteCode := iSiteCode;
	arCurrDataPoint.rTotalActivePower :=rTotalActivePower;
	arCurrDataPoint.rTotalReactivePower:=rTotalReactivePower;
	arCurrDataPoint.rTotalApparentPower:=rTotalApparentPower;
	arCurrDataPoint.rTotalPowerFactorPF:=rTotalPowerFactorPF;
	arCurrDataPoint.rTotalActiveEnergy:=rTotalActiveEnergy;
	arCurrDataPoint.rTotalReactiveEnergy:=rTotalReactiveEnergy;
	arCurrDataPoint.xRotatingField:=xRotatingField;


	arCurrDataPoint.arFrequency_1:=arFrequency[1];
	arCurrDataPoint.arVoltage_L_N_1:=arVoltage_L_N[1];
	arCurrDataPoint.arCurrent_1:=arCurrent[1];

	arCurrDataPoint.arFrequency_2:=arFrequency[2];
	arCurrDataPoint.arVoltage_L_N_2:=arVoltage_L_N[2];
	arCurrDataPoint.arCurrent_2:=arCurrent[2];

	arCurrDataPoint.arFrequency_3:=arFrequency[3];
	arCurrDataPoint.arVoltage_L_N_3:=arVoltage_L_N[3];
	arCurrDataPoint.arCurrent_3:=arCurrent[3];

	arCurrDataPoint.timeStamp := Get_Time();

	arCurrDataPoint.DCV1 := DCV1;
	arCurrDataPoint.DCV2:=DCV2;
	arCurrDataPoint.DCPower1:=DCPower1;
	arCurrDataPoint.DCPower2:=DCPower2;
	arCurrDataPoint.DCCurr2:=DCCurr2;
	arCurrDataPoint.DCCurr2:=DCCurr2;


	Create_Data_Point := arCurrDataPoint;
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Utils' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION Create_Path : STRING
VAR_INPUT
END_VAR
VAR
	sFilePath: STRING;
END_VAR
(* @END_DECLARATION := '0' *)
IF gc_xWriteToSD THEN
	sFilePath := '/media/sd/';
ELSE
	sFilePath := '';
END_IF

Create_Path := CONCAT(sFilePath, gc_sFileName);
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Utils' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION Get_Time : STRING
VAR_INPUT

END_VAR
VAR
	TimeStamp: STRING;
	SystemTime: SysTime64;
	Time_date: SystemTimeDate;
	TimeDate: CurTimeEx;
	iHours:INT;
	iMinutes:INT;
	iSeconds: INT;
	iDay: INT;
	iMonth: INT;
	iYear: INT;

END_VAR

(* @END_DECLARATION := '0' *)
(* Haal de systeemtijd op *)
TimeDate(SystemTime:= SystemTime, TimeDate:= Time_date);

(* Sla uren en minuten apart op *)
iHours := Time_date.Hour;
iMinutes := Time_date.Minute;
iSeconds := Time_date.Second;
iDay := Time_date.Day;
iMonth := Time_date.Month;
iYear := Time_date.Year;

TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iYear));
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iMonth));
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iDay));
TimeStamp := CONCAT(TimeStamp,'T');
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iHours));
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iMinutes));
TimeStamp := CONCAT(TimeStamp,INT_TO_STRING(iSeconds));
TimeStamp := CONCAT(TimeStamp,'Z');

Get_Time := TimeStamp;




END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Utils' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
(*---------------------------------------------------------------------------------------
  WAGO Kontakttechnik GmbH Hansastr. 27 32423 Minden(Westf.) 
  Tel. +49571/887-0 Fax. +49571/887-0                
                                                                                                
  Project: IEC1131 internal library
  
  Function: MEMCPY
  Description: This function copies BytesToCopy bytes from the source
                         address pSourceAddress to the destination address
                         pDestinationAddress
  Date: 25.09.2000

------------------------------------------------------------------------------------------*)
FUNCTION MEMCPY:BOOL
VAR_INPUT
	pSourceAddress:							POINTER TO ARRAY[1..2] OF BYTE;
	pDestinationAddress:						POINTER TO ARRAY[1..2] OF BYTE;
	BytesToCopy:								DINT;
END_VAR
VAR
END_VAR
(* @END_DECLARATION := '0' *)
WHILE (BytesToCopy > 0) DO
	pDestinationAddress^[1]:=pSourceAddress^[1]; (* copy bytes from source to destination *)
	pDestinationAddress:=ADR(pDestinationAddress^[2]); (* increment destination *)
	pSourceAddress:=ADR(pSourceAddress^[2]);(* increment source *)
	BytesToCopy:=BytesToCopy -1; (* decrement number of bytes to copy *)
END_WHILE
END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Utils' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM ReadCSVFile
VAR_INPUT
	sFilename		:STRING;
	bSeperator		:BYTE:=59;(*seperator semicolon:59=;*)
END_VAR
VAR_IN_OUT
	xStart			:BOOL;
	typData			:ARRAY [1..iMaxParams] OF  typCSV;
END_VAR
VAR_OUTPUT
	sStatus			:STRING;
END_VAR
VAR
	bEndOfFile		:BYTE:=13;
	FileIdent		:DWORD;
	rawdata			:ARRAY[0..gc_RawDataSize] OF BYTE;
	filesizev		:DINT;
	tempstring		:STRING;
	startposition	:INT;
	i				:INT;
	j				:INT;
	k				:INT;
END_VAR
(* @END_DECLARATION := '0' *)
IF xStart THEN
	FileIdent:=SysFileOpen(FileName:=sFilename, Mode:='r');
	IF fileident<>0 THEN
		SysFileRead(File:=Fileident, Buffer:=ADR(rawdata), Size:=SIZEOF(rawdata));
		filesizev:=SysFileGetSize(FileName:=sFilename);
		IF filesizev>gc_RawDataSize THEN
			filesizev:=gc_RawDataSize;
		END_IF
		SysFileClose(File:=fileident);(*this function is blocking*)
	ELSE
		sStatus:='File does not exist';
		xStart:=FALSE;
		RETURN;(*no such file available*)
	END_IF
(*copy data to typData array*)
	startposition:=0;
	i:=0;
	FOR j:=1 TO iMaxParams DO
		(*First value in dataset is of type DT. The following value is seperated by bSeperator*)
		WHILE rawdata[startposition+i]<>bSeperator DO
			i:=i+1;
		END_WHILE
		rawdata[startposition+i]:=0;
		MEMCPY(pSourceAddress:=ADR(rawdata[startposition]), pDestinationAddress:=ADR(tempstring), BytesToCopy:=i+1);
		typdata[j].sDescription:=tempstring;
		startposition:=startposition+i+1;
		i:=0;
		(*The parameter values are of type word. The following values are seperated by bSeperator*)
		FOR k:=1 TO gc_ParameterCount-1 DO
			WHILE rawdata[startposition+i]<>bSeperator DO
				i:=i+1;
			END_WHILE
			rawdata[startposition+i]:=0;
			MEMCPY(pSourceAddress:=ADR(rawdata[startposition]), pDestinationAddress:=ADR(tempstring), BytesToCopy:=i+1);
			typdata[j].Parameter[k]:=STRING_TO_REAL(tempstring);
			startposition:=startposition+i+1;
			i:=0;
		END_FOR
		(*Copying the last parameter from typ word. The data set is terminated by CR LF*)
		WHILE rawdata[startposition+i]<>bEndOfFile DO
			i:=i+1;
		END_WHILE
		rawdata[startposition+i]:=0;
		MEMCPY(pSourceAddress:=ADR(rawdata[startposition]), pDestinationAddress:=ADR(tempstring), BytesToCopy:=i+1);
		typdata[j].Parameter[k]:=STRING_TO_REAL(tempstring);
		startposition:=startposition+i+2;(*The data set is terminated by CR LF(13,10)*)
		i:=0;
	END_FOR
(*copy data to typData array finished*)
	sStatus:='Data read OK';
	xStart:=FALSE;
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '\/Utils' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM WriteCSVFile
(* 	This function block Writes the contents of the data structure to a CSV File

	Required Libraries:
		Standard.lib
		SysLibFile.lib
*)
VAR_INPUT
	sFILENAME 		:STRING(80); (* Filename to store data to (e.g. 'config.csv' 		*)
	toWrite  			:STRING(500);
	bSeperator		:BYTE :=59;	(* Seperator semicolon:59=;*)
END_VAR
VAR_IN_OUT
	xStart 			:BOOL;	(* Set TRUE to write data, set False to stop.		 *)
END_VAR
VAR_OUTPUT
	sStatus			:STRING;
	iError 			:INT;	(* 00 : Normal Operation	*)
							(* 90 : Can't Open File 	*)
							(* 91 : Can't Close File 	*)
							(* 92 : Can't Write to File 	*)
END_VAR
VAR
	FileOpen		:BOOL := FALSE;
	handle			:DWORD;
	Mode			:STRING[20] := 'rw'; (* read/write *)
	DataString 		:STRING(80);
	i				:INT;
END_VAR
(* @END_DECLARATION := '0' *)
IF xStart THEN
	sStatus := 'Try to open file';
	IF NOT FileOpen THEN
		(* Open File *)
		handle := SysFileOpen(sFileName, Mode);
		IF handle > 0 THEN
			FileOpen := TRUE;
			sStatus := 'File Open OK.';
		ELSE
			iERROR := 90; (* Could not open file. *)
			sStatus := 'Could not open file.';
		END_IF
	END_IF

	IF FileOpen THEN
				IF SysFileWrite(handle, ADR(toWrite), LEN(toWrite)) = 0 THEN
					iERROR := 92; (* Could not write to file *)
					sStatus := 'Could not write file.';
				END_IF
	END_IF

	IF FileOpen THEN
		(* Close file *)
		IF SysFileClose(handle) THEN
			FileOpen := FALSE;
			sStatus := 'File Saved.';
		ELSE
			iERROR := 91; (* Could not close file *)
			sStatus := 'Could not close file.';
		END_IF
		xStart := FALSE;
	END_IF
END_IF
END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK Log_to_CSV
VAR_INPUT
(*array of data we wish to log to CSV, each data type should be in a seperate CSV?*)
	arToLogData:         ARRAY[1..gc_iTotalParams] OF REAL;

END_VAR
VAR_OUTPUT
END_VAR
VAR
	(*CSV logging variables*)
	(* TODO clean this up removed unused variables*)
	xLoad			: BOOL; (* Initiate load operation *)
	xSave			: BOOL; (* Initiate save operation *)
	sLoadStatus		: STRING; (* Feedback on load *)
	sSaveStatus		: STRING; (* Feedback on save *)
	ConfigData		: ARRAY [1..iMaxParams] OF  typCSV; (* Structure with the config data being loaded or saved *)
	bufferString		:STRING(500);
	bSeperator 		: BYTE := 59; (* Semicolon (;) is the seperator between parameter and value. *)
	iError			: INT; (* Error Code for Save *)

	sFilePath		: STRING; (* SD card is S:\, Internal Path is blank, but this points to the PLC folder *)

	i: INT;
END_VAR
(* @END_DECLARATION := '0' *)
sFilePath := Create_Path();

(* initializse buffer log value *)
bufferString := CONCAT(bufferString , INT_TO_STRING(gv_iBuffCounter) );
bufferString := CONCAT(bufferString , ',' );

(* take the data in array and convert into CSV string format*)
FOR i:=0 TO gc_iTotalParams - 1 DO
	bufferString := CONCAT(bufferString , REAL_TO_STRING(arToLogData[i]));
	bufferString := CONCAT(bufferString , ',' );

	bufferString := CONCAT(bufferString,ASCIIBYTE_TO_STRING(13)); (* CR *)
	bufferString := CONCAT(bufferString,ASCIIBYTE_TO_STRING(10)); (* LF *)

END_FOR
(* function call isn't working right now*)
(*WriteCSVFile(sFilePath,bufferString);*)
gv_iBuffCounter := + 1;
END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM Main_logger
VAR
	xDoIt : BOOL;
	wState : WORD; (* Statemachine*)
	oMySql : MySql_Context; (* Used like Structure for keeping login and status information - Do not call it with in your program *)


	(* working data points *)
	arCurrDataPoint : DataPoint;


	hasBufferedItems :  BOOL; (*Flag indicating the status of the buffer *)
	TONInst : TON; (* Sleep timer  *)


	(* Functionblock to contact MySql server *)
	oMySqlLogin : MySql_Login;

	xConnect : BOOL;
	diErrorLogin : DINT;
	sStatusLogin : STRING(500);
	xConnected : BOOL;


	(* Paremeters for 494 power measurement configuration *)
	xEnable							: BOOL:= TRUE;				(* Activates the function block 											II Aktivierung des Bausteins *)
	tCycleTime						: TIME:=t#1s;					(* Cycletime for reading values											II Zykluszeit für das Auslesen der Messwerte *)
	abIn_750_494 AT %IB72 : ARRAY [0..23] OF BYTE;
       abOut_750_494 AT %QB72:  ARRAY [0..23] OF BYTE;
	d750_494                               :  Fb_750_494_AC_Compact_01;  (* local function block instance*)

	(*Genset*)
	gensetINS :GENSETCheck;


	(* Output DC variables *)
	dc_measure : POWER_MEASURMENT_DC;
	DCV1 :REAL;
	DCV2 :REAL;
	DCPower1: REAL;
	DCPower2: REAL;
	DCCurr1 : REAL;
	DCCurr2 : REAL;

	(* Output variables from 494 *)
      bToken							      : BYTE;
	xReady							: BOOL; 						(* Signal that the last read process is finished 							II Anzeige, dass der letzte Lesevorgang abgeschlossen ist*)
	rTotalActivePower					: REAL;						(* Tota lActive Power 														II Wirkleistung gesamt *)
	rTotalReactivePower				: REAL;						(* Total Reactive Power													II Blindleistung gesamt *)
	rTotalApparentPower				: REAL;						(* Total Apparent Power													II Scheinleistung gesamt *)
	rTotalPowerFactorPF				: REAL;						(* Total Power Factor PF 													II Leistungsfaktor_PF gesamt *)
	rTotalActiveEnergy				: REAL;						(* Total Active Energy	 													II Wirkenergie gesamt *)
	rTotalReactiveEnergy				: REAL;						(* Total Reactive Energy 													II Blindenergie gesamt *)
	rTotalApparentEnergy				: REAL;						(* Total Apparent Energy 													II Scheinenergie gesamt *)
	xRotatingField						: BOOL;						(* Rotating Field 															II Drehfeld rechts *)
	arFrequency						: ARRAY[1..3] OF REAL;		(* Frequency																II Frequenz *)
	arVoltage_L_N					: ARRAY[1..3] OF REAL;		(* Voltage L-N 																II Spannung Lx N *)
	arCurrent							: ARRAY[1..3] OF REAL;		(* Current 															   		II Strom *)
	abFeedback						: ARRAY[1..8] OF BYTE;		(*	0   = no Error 															II kein Fehler
																			1   = Invalid values measure ID 										II Einträge MID nicht gültig
																			2   = Timeout
																			3   = Function block not active 										II Baustein nicht aktiv
																			4   = Settings process active (read/write) 							II Parameterbearbeitung aktiv (Lesen/Schreiben)
																			16  = Overflow Value 1
																			32  = Overflow Value 2
																			48  = Overflow Value 1 + Overflow Value 2
																			64  = Overflow Value 3
																			80  = Overflow Value 1 + Overflow Value 3
																			96  = Overflow Value 2 + Overflow Value 3
																			112 = Overflow Value 1 + Overflow Value 2 + Overflow Value 3
																			128 = Overflow Value 4
																			144 = Overflow Value 1 + Overflow Value 4
																			160 = Overflow Value 2 + Overflow Value 4
																			176 = Overflow Value 1 + Overflow Value 2 + Overflow Value 4
																			192 = Overflow Value 3 + Overflow Value 4
																			208 = Overflow Value 1 + Overflow Value 3 + Overflow Value 4
																			224 = Overflow Value 2 + Overflow Value 3 + Overflow Value 4
																			240 = Overflow Value 1 + Overflow Value 2 + Overflow Value 3 + Overflow Value 4*)



	(* Functionblock to process SQL statements who do not return result sets *)
	oMySqlExec1 : MySql_Execute;
	asSqlStatement1 : ARRAY [0..gcMySql_iSqlUpperBound] OF STRING(gcMySql_iSqlLength);
	xExec1 : BOOL;
	diErrorExec1 : DINT;
	sStatusExec1 : STRING(700);

	(*TODO clean this up these might be unnecassar delete if not used *)
	(* Functionblock to process SQL statements who return result sets *)
	oMySqlQuery1 : MySql_Query;
	asSqlQuery1 : ARRAY [0..gcMySql_iSqlUpperBound] OF STRING(gcMySql_iSqlLength);
	xQuery1 : BOOL;
	diErrorQuery1 : DINT;
	sStatusQuery1 : STRING(500);
	stQueryResult1 : MySql_ResultSet;


	(* Convert "stQueryResult" to IEC *)
	stTableData : TableData;
	row, col : INT;
	sValue: STRING(500); (* Returns the value of requested row and col as STRING *)
	dwResult: DWORD; (* Error code of function "MySql_Convert2IEC() *)
	xConvertError : BOOL;

	(* Functionblock to disconnect MySql server *)
	oMySqlLogout : MySql_Logout;
	xDisconnect : BOOL;
	diErrorLogout : DINT;
	sStatusLogout : STRING(500);

	(* Helpers *)
	iHelp : INT;
	i : INT;
	END_: BOOL;
	strTempSQLStatement: STRING(raw_SQL_STR_LENGTH);


	(* debug variables *)
	iCountExecFailed: INT;
	xDolt: BOOL;
END_VAR
(* @END_DECLARATION := '0' *)
(*Get AC power data every cycle*)


d750_494 (						    xEnable:=xEnable,
										tCycleTime:=tCycleTime,
										abOut_750_494:=abOut_750_494,
										abIn_750_494:=abIn_750_494,
										bToken:=bToken,
										xReady=>xReady,
										rTotalActivePower=> rTotalActivePower,
										rTotalReactivePower=>rTotalReactivePower,
										rTotalApparentPower=>rTotalApparentPower,
										rTotalPowerFactorPF=>rTotalPowerFactorPF,
										rTotalActiveEnergy=>rTotalActiveEnergy,
										rTotalReactiveEnergy=>rTotalReactiveEnergy,
										rTotalApparentEnergy=>rTotalApparentEnergy,
										xRotatingField=>xRotatingField,
										arFrequency=>arFrequency,
										arVoltage_L_N=>arVoltage_L_N,
										arCurrent=>arCurrent,
										abFeedback=>abFeedback
										);


(*  Get DC measurement *)
dc_measure(
	tCycleTime:=tCycleTime,
	DCV1=> DCV1,
	DCV2=>DCV2,
	DCPower1=>DCPower1 ,
	DCPower2=>DCPower2,
	DCCurr1=>DCCurr1 ,
	DCCurr2=>DCCurr2 );

(*check genset situation*)
gensetINS(DCBatteryVoltage:=DCV1);

(* Call function block "MySql_Login" every cycle to monitor connection status *)
oMySqlLogin(sHost:= gc_sHost,
			uiPort:= gc_uiPort,
			sUsername:= gc_sUser,
			sPassword:= gc_sPwd,
			sDatabase:=gc_sDB,
			oMySql:= oMySql,
			xStart:= xConnect,
			diError=> diErrorLogin,
			sStatus=> sStatusLogin,
			xConnected=> xConnected);



CASE wState OF
0:

	xConnect := TRUE;
	wState := 10;

10:
	IF xConnected THEN

		xConnect := FALSE;
		IF xRotatingField  THEN  (*  Check that our power measurment model  is ready *)
			wState := 20; (* Proceede to execute SQL*)
		ELSE
			(* this is a different error state *)
			wState:= 45; (* wait and go to holding pattern for power measurement sensor to be ready*)
		END_IF
	ELSE
		wstate:=0;
	END_IF

20: (* prepare sql statement *)
	(*Create data point object to pass around *)
	IF hasBufferedItems THEN
		arCurrDataPoint := gv_Buffer[gv_iBuffPointer];
	ELSE
		arCurrDataPoint := Create_Data_Point (
													iSiteCode:=gc_iSiteCode,
													rTotalActivePower:=rTotalActivePower,
													rTotalReactivePower:=rTotalReactivePower,
													rTotalApparentPower:=rTotalApparentPower,
													rTotalPowerFactorPF:=rTotalPowerFactorPF,
													rTotalActiveEnergy:=rTotalActiveEnergy,
													rTotalReactiveEnergy:=rTotalReactiveEnergy,
													rTotalApparentEnergy:=rTotalApparentEnergy,
													xRotatingField:=xRotatingField,
													arFrequency:=arFrequency,
													arVoltage_L_N:=arVoltage_L_N,
													arCurrent:=arCurrent,
													DCV1 :=DCV1,
													DCV2 :=DCV2,
													DCPower1:= DCPower1,
													DCPower2:= DCPower2,
													DCCurr1 := DCCurr1,
													DCCurr2 :=DCCurr2);
	END_IF
	(* Create AC Statment *)
	asSqlStatement1  := SQLStatement(       toLog     := arCurrDataPoint,
												s_Table:= gc_sTable,
											);


	xExec1 := TRUE; (* Execute SQL-Insert-Statement *)
	wState :=25;

25:
	oMySqlExec1(asSqlCommand:=asSqlStatement1,
					oMySql:=oMySql,
					xStart:=xExec1,
					diError=> diErrorExec1,
					sStatus=>sStatusExec1);

	IF NOT  xExec1 THEN
		(* success *)
			xDisconnect := TRUE;
			wState := 46  (*finished go and disconnect or start again *);
		IF diErrorExec1 = 0 THEN
			IF hasBufferedItems THEN
				IF gv_iBuffCounter = gv_iBuffPointer THEN
					(*Buffer has been cleared reset counters*)
					gv_iBuffCounter := 0;
					gv_iBuffPointer := 0;
					hasBufferedItems := FALSE;
				ELSE
					gv_iBuffPointer := gv_iBuffPointer + 1; (*item pushed was buffered increment pointer *)
				END_IF
			END_IF
		ELSE
			(* Failed *)
			iCountExecFailed := iCountExecFailed +1; (* TODO count number of failures and fire an alarm *)
			wState:=45;
		END_IF
	END_IF


45: (* Wait here to debug convert problem *)
	(* buffer current value into memory *)
	IF gv_iBuffCounter < gc_MaxBufferSize THEN
		gv_Buffer[gv_iBuffCounter] := arCurrDataPoint;
		gv_iBuffCounter := gv_iBuffCounter + 1;
		hasBufferedItems := TRUE; (*Flag indicating the status of the buffer *)
	END_IF
	wState := 46; (*move onto sleep*)

(*sleep X amount of time and continue*)
46:
	TONInst( IN:= TRUE, PT := gc_LogInterval);

	IF TONInst.Q THEN
			wState := 0;
		(* do nothing just wait*)
	END_IF

50: (* Disconnect from database *)
	oMySqlLogout(oMySql:= oMySql,
				 xStart:= xDisconnect,
				 diError=> diErrorLogout,
				 sStatus=> sStatusLogout);
	IF NOT xDisconnect THEN
		xDoIt := FALSE;
		wState := 0;
	END_IF
END_CASE




END_PROGRAM


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION SPLIT_TO_STR_ARRAY : ARRAY [0..gcMySql_iSqlUpperBound] OF STRING(gcMySql_iSqlLength)
VAR_INPUT
	sInputString :      STRING;
	iSizeSplit   :      INT;

END_VAR
VAR

	tempARR: ARRAY [0..gcMysql_iSqlUpperBound] OF STRING(gcMySql_iSqlLength);		(*Temporarry array to merge results	*)
	i: INT := 0;
	iBeginPointer: INT := 0;
	iArraySizeCheck: INT;

END_VAR
(* @END_DECLARATION := '0' *)
(*not using this creatring array maually instead as it doesn't simplify anything*)

iArraySizeCheck := LEN(sInputString) / iSizeSplit; (* We need to see how many slices of the string we will have*)

IF iArraySizeCheck < gcMySql_iSqlUpperBound THEN (* Check that the array we have has enough space to fit these strings*)
	WHILE i  <  gcMysql_iSqlUpperBound  DO
		tempARR[i] := MID( sInputString , iSizeSplit, iBeginPointer);
		i :=  i + 1;
		iBeginPointer := IBeginPointer + iSizeSplit;

	END_WHILE
	SPLIT_TO_STR_ARRAY := tempARR;

END_IF


END_FUNCTION


(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION SQLStatement : ARRAY [0..gcMySql_iSqlUpperBound] OF STRING(gcMySql_iSqlLength)
VAR_INPUT

	toLog:  DataPoint;
	s_Table : STRING;

END_VAR
VAR
	rTotalActivePower					: REAL;						(* Tota lActive Power 														II Wirkleistung gesamt *)
	rTotalReactivePower				: REAL;						(* Total Reactive Power													II Blindleistung gesamt *)
	rTotalApparentPower				: REAL;						(* Total Apparent Power													II Scheinleistung gesamt *)
	rTotalPowerFactorPF				: REAL;						(* Total Power Factor PF 													II Leistungsfaktor_PF gesamt *)
	rTotalActiveEnergy				: REAL;						(* Total Active Energy	 													II Wirkenergie gesamt *)
	rTotalReactiveEnergy				: REAL;						(* Total Reactive Energy 													II Blindenergie gesamt *)
	rTotalApparentEnergy				: REAL;						(* Total Apparent Energy 													II Scheinenergie gesamt *)
	xRotatingField						: BOOL;						(* Rotating Field 															II Drehfeld rechts *)
	arFrequency						: ARRAY[1..3] OF REAL;		(* Frequency																II Frequenz *)
	arVoltage_L_N					: ARRAY[1..3] OF REAL;		(* Voltage L-N 																II Spannung Lx N *)
	arCurrent							: ARRAY[1..3] OF REAL;		(* Current 															   		II Strom *)

	DCV1 :REAL;
	DCV2 :REAL;

	DCPower1: REAL;
	DCPower2: REAL;

	DCCurr1 : REAL;
	DCCurr2 : REAL;

	iSiteCode: INT;

END_VAR
(* @END_DECLARATION := '0' *)

iSiteCode := toLog.iSiteCode;

		(*DC measurement data send *)
		DCV1 := toLog.DCV1 ;
		DCV2 := toLog.DCV2;

		DCPower1:=  toLog.DCPower1;
		DCPower2:=  toLog.DCPower2;
	
		DCCurr1 :=toLog.DCCurr1 ;
		DCCurr2 := toLog.DCCurr2;

		(*AC Daat point *)
		(*TODO time stamp needs to be added if buffered data *)
		rTotalActivePower := toLog.rTotalActivePower;
		rTotalReactivePower := toLog.rTotalReactivePower;
		rTotalApparentPower := toLog.rTotalApparentPower;
		rTotalPowerFactorPF := toLog.rTotalPowerFactorPF;
		rTotalActiveEnergy := toLog.rTotalActiveEnergy;
		rTotalApparentEnergy := toLog.rTotalApparentEnergy;
		xRotatingField := toLog.xRotatingField;
		arFrequency[1] := toLog.arFrequency_1;
		arVoltage_L_N[1] := toLog.arVoltage_L_N_1;
		arCurrent[1] := toLog.arCurrent_1;
		arFrequency[2] := toLog.arFrequency_2;
		arVoltage_L_N[2] := toLog.arVoltage_L_N_2;
		arCurrent[2] := toLog.arCurrent_2;
		arFrequency[3] := toLog.arFrequency_3;
		arVoltage_L_N[3] := toLog.arVoltage_L_N_3;
		arCurrent[3] := toLog.arCurrent_3;
		
		SQLStatement[0] := 'INSERT INTO ';
		SQLStatement[1] := s_Table;
		SQLStatement[2] :=  ' ( rTotalActivePower , rTotalReactivePower , rTotalApparentPower, rTotalPowerFactorPF, rTotalActiveEnergy, rTotalReactiveEnergy, rTotalApparentEnergy,  xRotatingField, arFrequency1 , arFrequency2 ,arFrequency3,arVoltage_L_N1,arVoltage_L_N2, arVoltage_L_N3, arCurrent1,arCurrent2,arCurrent3,DCVolt1,DCVolt2,DCCurr1,DCCurr2 ,DCPower1,DCPower2,iSiteCode)  VALUES ( ';
		(* AC Values *)
		SQLStatement[3] :=  CONCAT(REAL_TO_STRING(rTotalActivePower), ',');
		SQLStatement[4] :=  CONCAT(REAL_TO_STRING(rTotalReactivePower), ',');
		SQLStatement[5] :=  CONCAT(REAL_TO_STRING(rTotalApparentPower), ',');
		SQLStatement[6] :=  CONCAT(REAL_TO_STRING(rTotalPowerFactorPF), ',');
		SQLStatement[7] :=  CONCAT(REAL_TO_STRING(rTotalActiveEnergy), ',');
		SQLStatement[8] :=  CONCAT(REAL_TO_STRING(rTotalReactiveEnergy), ',');
		SQLStatement[9] :=  CONCAT(REAL_TO_STRING(rTotalApparentEnergy), ',');
		SQLStatement[10] :=  CONCAT(BOOL_TO_STRING(xRotatingField), ',');

		SQLStatement[11] :=  CONCAT(REAL_TO_STRING(arFrequency[1]), ',');
		SQLStatement[12] :=  CONCAT(REAL_TO_STRING(arFrequency[2]), ',');
		SQLStatement[13] :=  CONCAT(REAL_TO_STRING(arFrequency[3]), ',');

		SQLStatement[14] :=  CONCAT(REAL_TO_STRING( arVoltage_L_N[1] ), ',');
		SQLStatement[15] :=  CONCAT(REAL_TO_STRING( arVoltage_L_N[2] ), ',');
		SQLStatement[16] :=  CONCAT(REAL_TO_STRING( arVoltage_L_N[3] ), ',');

		SQLStatement[17] :=  CONCAT(REAL_TO_STRING(arCurrent[1] ), ',');
		SQLStatement[18] :=  CONCAT(REAL_TO_STRING(arCurrent[2]), ',');
		SQLStatement[19] :=  CONCAT(REAL_TO_STRING(arCurrent[3]), ',');

		(*  DC Values *)
		SQLStatement[20] :=  CONCAT(REAL_TO_STRING(DCV1), ',');
		SQLStatement[21] :=  CONCAT(REAL_TO_STRING(DCV2), ',');

		SQLStatement[22] :=  CONCAT(REAL_TO_STRING(DCCurr2), ',');
		SQLStatement[23] :=  CONCAT(REAL_TO_STRING(DCCurr2), ',');

		SQLStatement[24] :=  CONCAT(REAL_TO_STRING(DCPower1), ',');
		SQLStatement[25] :=  CONCAT(REAL_TO_STRING(DCPower1), ',');

		SQLStatement[26] :=  CONCAT(INT_TO_STRING(iSiteCode), ' )' );


END_FUNCTION

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE DataPoint :
	STRUCT
		(*Common variables*)
		iSiteCode:INT;
		timeStamp: STRING;

		(*AC Variables*)
		rTotalActivePower:REAL;
		rTotalReactivePower:REAL;
		rTotalApparentPower:REAL;
	      rTotalPowerFactorPF:REAL;
		rTotalActiveEnergy:REAL;
		rTotalReactiveEnergy:REAL;
		rTotalApparentEnergy:REAL;
		xRotatingField:BOOL;
		arFrequency_1:REAL;
		arVoltage_L_N_1:REAL;
		arCurrent_1:REAL;
		arFrequency_2:REAL;
		arVoltage_L_N_2:REAL;
		arCurrent_2:REAL;
		arFrequency_3:REAL;
		arVoltage_L_N_3:REAL;
		arCurrent_3:REAL;

		(* DC Variables *)
		DCV1 :REAL;
		DCV2 :REAL;
		DCPower1: REAL;
		DCPower2: REAL;
		DCCurr1 : REAL;
		DCCurr2 : REAL;


		END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE RowData :
  STRUCT
  	dtDt 		: DT; 		(* Table field "timestamp" 	- MySql_Datatype "datetime" 	*)
  	asString 	: ARRAY [0..9] OF STRING(255);	(* Table fields "s0"-"s9" MySql_Datatype "varchar(255)" 	*)
  END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE TableData :
  STRUCT
	xValid : BOOL;
	iRowCount : INT;
	astRow : ARRAY [0..gcMySql_dwMaxRowCount] OF RowData;
  END_STRUCT
END_TYPE

(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
TYPE typCSV :
STRUCT
	sDescription	:STRING;
	Parameter		:ARRAY[1..gc_ParameterCount] OF REAL;
END_STRUCT
END_TYPE
(* @END_DECLARATION := '0' *)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Global_Variables' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_GLOBAL

	gv_sFilePath: STRING;
	gv_iBuffCounter			:INT := 0; (* counter for  buffer*)
	gv_iBuffPointer			:INT := 0; (* pointer  for  buffer*)
	gv_Buffer					:ARRAY[0..gc_MaxBufferSize] OF DataPoint; (*In memory buffer of failed message attempts*)
	gv_isGenSetON                 :BOOL;
	gv_DCGenCycleCount     : INT :=0 ;

END_VAR
VAR_GLOBAL CONSTANT

	(* Site specific variables*)
	gc_iSiteCode: INT := 1000; (*1000 is code for Nyange this needs to be somehow made dynamic and unique for each site*)


	MAX_ROWS : WORD := 30; (* Array size for converted table data *)

	gcMySql_iSqlUpperBound: INT := 29; (* Defines the upper bound of "asSqlStatement",
				used by function blocks "MySql_ExecSql" and "MySql_Query" 
				to provide an SQL statement as "ARRAY [0..UpperBound] OF STRING(Size)".
	*)

	gcMySql_iSqlLength: INT := 370; (* Defines the size in byte of an array element
				of "asSqlStatement", used by function blocks "MySql_ExecSql" and "MySql_Query" 
				to provide an SQL statement as "ARRAY [0..UpperBound] OF STRING(Size)".
	*)
	raw_SQL_STR_LENGTH: INT := 350;

	(* MYSQL configs *)
	gc_sHost : STRING := '### your mysql server address here'';  (*'application.dyndns.info';*)
	gc_uiPort : UINT := 3306;
	gc_sUser : STRING := '### your mysql server username ';
	gc_sPwd : STRING := '### your mysql password';
	gc_sDB : STRING := '### your MYSQL database;   	(* Optional - Name of database instance to connect to *)
	gc_sTable:STRING := '###' your MYSql table' ;

	(* CSV Writing/Logging parameters*)
	gc_xWriteToSD: BOOL := TRUE;

	iMaxParams			:INT:=5;(* Number of Parameters per File *)
	gc_ParameterCount	:INT:=1;(* Number of Values per Parameter *)
	gc_RawDataSize		:UINT:=500; (* Raw data size for reading in file ASCII *)
	gc_MaxBufferSize 	       :INT := 5000; (*number of items to hold in memory*)
	gc_sFileName		: STRING := 'buffer.csv'; (* Working Filename   Complete path + filename *)

	(* Logging constants*)
	gc_LogInterval             :TIME := T#10s;
	gc_iTotalParams		:INT := 18;

	(* generator constants*)
	gc_DCVoltageGenSetON :REAL := 24;
	gc_DCVoltageGenSetOFF :REAL := 26;

	(*how many cycles do we wait before we trigger the genset need to calculate based no cycletime *gc_DCGenCycleCount = total_seconds  *)
	gc_DCGenCycleCount       :INT := 40;

END_VAR

(* @OBJECT_END := 'Global_Variables' *)
(* @CONNECTIONS := Global_Variables
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)

(* @NESTEDCOMMENTS := 'Yes' *)
(* @GLOBAL_VARIABLE_LIST := 'Variable_Configuration' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
VAR_CONFIG
END_VAR

(* @OBJECT_END := 'Variable_Configuration' *)
(* @CONNECTIONS := Variable_Configuration
FILENAME : ''
FILETIME : 0
EXPORT : 0
NUMOFCONNECTIONS : 0
*)


_ALARMCONFIG
_ALARMCONFIGNEXTTEXTID : 10002
_ALARMCONFIGFORMATS : 'HH$':$'mm$':$'ss','dd$'-$'MM$'-$'yyyy'
_ALARMCLASSLIST : 1
_ALARMCLASSID : 0
_ALARMCLASSACKTYPE : 0
_ALARMCLASSNAME : 'DEFAULT'
_ALARMCLASSDESCRIPTION : ''
_ALARMCLASSBGCOLORS : 16777215,16777215,16777215
_ALARMCLASSTEXTCOLORS : 3394560,255,16711680
_ALARMCLASSBITMAPS : '','',''
_ALARMACTIONLIST : 0
(* @ALARMCLASSRESETCOLORS := '_ALARMCLASSRESETCOLORS: 33023,16777215' *)
(* @ALARMCLASSRESETBITMAP := '_ALARMCLASSRESETBITMAP: $'$'' *)
_ALARMGROUPLISTNAME : 'System'
_ALARMGROUPPATH : 'System'
_ALARMGROUPLIST : 0
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0

(* @ALARMCONFIGFLAGS := '_ALARMCONFIGFLAGS: 4' *)
(* @ALARMCONFIGGLOBALDB_STR := '_ALARMCONFIGGLOBALDB_STRINGS: $'$',$'$',$'$',$'$'' *)
(* @ALARMCONFIGGLOBALDB_NUM := '_ALARMCONFIGGLOBALDB_NUMBERS: 0,0' *)
_END_ALARMCONFIG


LIBRARY
C:\Program Files (x86)\WAGO Software\CoDeSys V2.3\Targets\WAGO\Libraries\POWER_MEASUREMENT\PowerMeasurement_494_02.lib 7.10.15 13:30:30
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 27
Fb_750_494_AC_Compact_01: 2048
Fb_750_494_AC_Values: 2048
Fb_750_494_AC_Values.GetMultiplicator: 2048
Fb_750_494_Configuration: 2048
Fb_750_494_Configuration.GetCommand: 2048
Fb_750_494_Configuration.GetMultiplicator: 2048
Fb_750_494_Configuration.GetParamValue: 2048
Fb_750_494_Configuration.GetRegisterValue: 2048
Fb_750_494_Configuration.ParamChannelCommRead: 2048
Fb_750_494_Configuration.ParamChannelCommWrite: 2048
Fb_750_494_Configuration.ProcessParamValues: 2048
Fb_750_494_Configuration.ProcessRegValues: 2048
Fb_750_494_Configuration.RegisterCommRead: 2048
Fb_750_494_Configuration.RegisterCommWrite: 2048
Fb_750_494_Configuration.SendCommand: 2048
Fb_750_494_Configuration.SynchronizeUI: 2048
Fb_750_494_DC_Values: 2048
Fb_750_494_DC_Values.GetMultiplicator: 2048
Fb_750_494_Harmonic_Values: 2048
Fb_750_494_Harmonic_Values.GetMultiplicator: 2048
Fb_750_494_State: 2048
Fu494ScaleValue: 2048
Func_750_494_Collection007Context: 2048
Func_750_494_Collection009Context: 2048
Func_750_494_CollectionXXXContext: 2048
Func_750_494_ConfigConsistency: 2048
FuVersion_750_494: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
Iecsfc.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 1
SFCActionControl: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
mod_com.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 11
ADD_PI_INFORMATION: 0
CRC16: 0
FBUS_ERROR_INFORMATION: 0
GET_DIGITAL_INPUT_OFFSET: 0
GET_DIGITAL_OUTPUT_OFFSET: 0
KBUS_ERROR_INFORMATION: 0
MOD_COM_VERSION: 0
PI_INFORMATION: 0
SET_DIGITAL_INPUT_OFFSET: 0
SET_DIGITAL_OUTPUT_OFFSET: 0
SLAVE_ADDRESS: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
Modb_l05.lib 22.4.13 12:50:12
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 21
ASCII_TO_RTU: 2048
MB_CRC: 2048
MB_HEX_TO_BYTE: 0
MODBUS_EXTENDED_MASTER: 2048
MODBUS_EXTENDED_MASTER_RTU: 2048
MODBUS_EXTENDED_SLAVE: 0
MODBUS_EXTENDED_SLAVE.MB_ACTION_LOOPBACK: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_READ_DISCRETE_INPUTS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_READ_INPUT_REGISTERS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_READ_WRITE_MULTIPLE_REGISTERS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_MASK_REGISTER: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_MULTIPLE_COILS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_MULTIPLE_REGISTERS: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_SINGLE_COIL: 2048
MODBUS_EXTENDED_SLAVE.MB_ACTION_WRITE_SINGLE_REGISTER: 2048
MODBUS_MASTER_RTU: 0
MODBUSMASTER_RTU: 2048
MODBUSMASTER_RTU_EN: 2048
MODBUSSLAVE_RTU: 8
RTU_TO_ASCII: 2048
Version_Modb_l05: 2048
NumOfGVLs: 1
Global_Constants: 2048
END_LIBRARY

LIBRARY
SerComm.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 2
SERCOMM: 0
SERCOMM_VERSION: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
Serial_Interface_01.lib 22.4.13 12:50:14
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 7
SERIAL_COM_OBJECT: 2048
SERIAL_INTERFACE: 2048
SERIAL_INTERFACE.CLOSE_PORT: 2048
SERIAL_INTERFACE.OPEN_PORT: 2048
SERIAL_INTERFACE.RECEIVE_DATA: 2048
SERIAL_INTERFACE.SEND_DATA: 2048
Version_SerialInterface: 2048
NumOfGVLs: 1
Globale_InterfaceConstant: 0
END_LIBRARY

LIBRARY
Standard.lib 20.5.14 08:13:26
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 26
ASCIIBYTE_TO_STRING: 2048
CONCAT: 0
CTD: 0
CTU: 0
CTUD: 0
DELETE: 0
F_TRIG: 0
FIND: 0
INSERT: 0
LEFT: 0
LEN: 0
MID: 0
R_TRIG: 0
REAL_STATE: 2048
REPLACE: 0
RIGHT: 0
RS: 0
RTC: 0
SEMA: 0
SR: 0
STANDARD_VERSION: 2048
STRING_COMPARE: 2048
STRING_TO_ASCIIBYTE: 2048
TOF: 0
TON: 0
TP: 0
NumOfGVLs: 1
'Global Variables 0': 0
END_LIBRARY

LIBRARY
SYSLIBCALLBACK.LIB 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 2
SysCallbackRegister: 0
SysCallbackUnregister: 0
NumOfGVLs: 2
Globale_Variablen: 0
Version: 0
END_LIBRARY

LIBRARY
SysLibFile.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 12
SysFileClose: 0
SysFileCopy: 0
SysFileDelete: 0
SysFileEOF: 0
SysFileGetPos: 0
SysFileGetSize: 0
SysFileGetTime: 0
SysFileOpen: 0
SysFileRead: 0
SysFileRename: 0
SysFileSetPos: 0
SysFileWrite: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
SysLibSem.lib 16.5.13 14:00:50
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 5
SysSemCreate: 0
SysSemDelete: 0
SysSemEnter: 0
SysSemLeave: 0
SysSemTry: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
SysLibSockets.lib 22.5.14 16:16:32
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 26
SysSockAccept: 0
SysSockBind: 0
SysSockClose: 0
SysSockConnect: 0
SysSockCreate: 0
SysSockGetHostByName: 0
SysSockGetHostName: 0
SysSockGetLastError: 2048
SysSockGetLastErrorSync: 2048
SysSockGetOption: 0
SysSockHtonl: 0
SysSockHtons: 0
SysSockInetAddr: 0
SysSockInetNtoa: 0
SysSockIoctl: 0
SysSockListen: 0
SysSockNtohl: 0
SysSockNtohs: 0
SysSockRecv: 0
SysSockRecvFrom: 0
SysSockSelect: 0
SysSockSend: 0
SysSockSendTo: 0
SysSockSetIPAddress: 0
SysSockSetOption: 0
SysSockShutdown: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
SysLibTime.lib 16.5.13 14:00:48
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 2
CurTime: 0
CurTimeEx: 0
NumOfGVLs: 1
Globale_Variablen: 0
END_LIBRARY

LIBRARY
Wago_MBCFG_COMMON_01.lib 5.12.13 11:10:18
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 0
NumOfGVLs: 0
END_LIBRARY

LIBRARY
Wago_MBCFG_SERIAL_01.lib 17.9.14 14:24:36
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 2
MBCFG_COM_SER_OBJECT: 2048
MBCFG_MASTER_SERIAL: 2048
NumOfGVLs: 0
END_LIBRARY

LIBRARY
WagoLibMySQL_03.lib 23.7.14 09:13:36
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 9
MySql_Close: 2048
MySql_Context: 2048
MySql_Execute: 2048
MySql_GetStringValue: 2048
MySql_Login: 2048
MySql_Logout: 2048
MySql_Query: 2048
MySql_Scramble: 2048
MySql_Version: 2048
NumOfGVLs: 1
Global_Variables: 2048
END_LIBRARY

LIBRARY
WagoLibSHA1.lib 19.9.11 08:14:42
(* @LIBRARYSYMFILEINFO := '0' *)
NumOfPOUs: 8
SHA1: 2048
SHA1Hex2String: 2048
SHA1Input: 2048
SHA1PadMessage: 2048
SHA1ProcessMessageBlock: 2048
SHA1Reset: 2048
SHA1Result: 2048
SHA1Version: 2048
NumOfGVLs: 1
Globale_Variablen: 2048
END_LIBRARY

PLC_CONFIGURATION
_GLOBAL
_VERSION: 3
_AUTOADR: 1
_CHECKADR: 0
_SAVECONFIGFILESINPROJECT: 1
_END_GLOBAL

_MODULE: '3S'
_SECTION_NAME: 'Root'
_INDEX_IN_PARENT: '-1'
_MODULE_NAME: 'PLC Configuration'
_NODE_ID: -1
_IECIN: %IB0
_IECOUT: %QB0
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_MODULE: '3S'
_SECTION_NAME: 'K_Bus'
_INDEX_IN_PARENT: '1'
_MODULE_NAME: 'K-Bus'
_NODE_ID: 0
_IECIN: %IB0
_IECOUT: %QB0
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: 'PFC200 CS 2ETH RS (FW03-...)'

_PARAMETER
_PARAM 201019000: 0, '1'
_PARAM 201019001: 0, '10000'
_PARAM 201019002: 0, '0'
_PARAM 201019003: 0, '1'
_END_PARAMETER

_MODULE: '3S'
_SECTION_NAME: 'Type_30_1_Channels'
_INDEX_IN_PARENT: '1'
_MODULE_NAME: '0750-0652#24 RS-232/RS-485 Interface adjustable (24 Bytes)'
_NODE_ID: 0
_IECIN: %IB120
_IECOUT: %QB120
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'BYTEOnB_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'I'
_IECADR: %IB0
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'BYTEOnB_Q'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'Q'
_IECADR: %QB0
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_30_1_Channels'
_INDEX_IN_PARENT: '2'
_MODULE_NAME: '0750-0652#24 RS-232/RS-485 Interface adjustable (24 Bytes)'
_NODE_ID: 1
_IECIN: %IB120
_IECOUT: %QB120
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'BYTEOnB_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'I'
_IECADR: %IB24
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'BYTEOnB_Q'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'Q'
_IECADR: %QB24
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_30_1_Channels'
_INDEX_IN_PARENT: '3'
_MODULE_NAME: '0750-0652#24 RS-232/RS-485 Interface adjustable (24 Bytes)'
_NODE_ID: 2
_IECIN: %IB144
_IECOUT: %QB144
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'BYTEOnB_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'I'
_IECADR: %IB48
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'BYTEOnB_Q'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'First Byte of 24'
_CHANNEL_MODE: 'Q'
_IECADR: %QB48
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_58_1_Channels'
_INDEX_IN_PARENT: '4'
_MODULE_NAME: '0750-0494 3-phase PoM480/ 1A'
_NODE_ID: 3
_IECIN: %IB168
_IECOUT: %QB168
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word'
_CHANNEL_MODE: 'I'
_IECADR: %IW36
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 1'
_CHANNEL_MODE: 'I'
_IECADR: %IW37
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '3'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 2'
_CHANNEL_MODE: 'I'
_IECADR: %IW38
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '4'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 3'
_CHANNEL_MODE: 'I'
_IECADR: %IW39
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '5'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 1'
_CHANNEL_MODE: 'I'
_IECADR: %ID20
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '6'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 2'
_CHANNEL_MODE: 'I'
_IECADR: %ID21
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '7'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 3'
_CHANNEL_MODE: 'I'
_IECADR: %ID22
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '8'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 4'
_CHANNEL_MODE: 'I'
_IECADR: %ID23
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '9'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word'
_CHANNEL_MODE: 'Q'
_IECADR: %QW36
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '10'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 1'
_CHANNEL_MODE: 'Q'
_IECADR: %QW37
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '11'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 2'
_CHANNEL_MODE: 'Q'
_IECADR: %QW38
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '12'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 3'
_CHANNEL_MODE: 'Q'
_IECADR: %QW39
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_58_1_Channels'
_INDEX_IN_PARENT: '5'
_MODULE_NAME: '0750-0494 3-phase PoM480/ 1A'
_NODE_ID: 4
_IECIN: %IB192
_IECOUT: %QB192
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word'
_CHANNEL_MODE: 'I'
_IECADR: %IW48
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 1'
_CHANNEL_MODE: 'I'
_IECADR: %IW49
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '3'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 2'
_CHANNEL_MODE: 'I'
_IECADR: %IW50
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '4'
_SYMBOLIC_NAME: ''
_COMMENT: 'Status Word 3'
_CHANNEL_MODE: 'I'
_IECADR: %IW51
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '5'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 1'
_CHANNEL_MODE: 'I'
_IECADR: %ID26
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '6'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 2'
_CHANNEL_MODE: 'I'
_IECADR: %ID27
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '7'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 3'
_CHANNEL_MODE: 'I'
_IECADR: %ID28
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'DWORDOnD_I'
_INDEX_IN_PARENT: '8'
_SYMBOLIC_NAME: ''
_COMMENT: 'process value 4'
_CHANNEL_MODE: 'I'
_IECADR: %ID29
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '9'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word'
_CHANNEL_MODE: 'Q'
_IECADR: %QW48
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '10'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 1'
_CHANNEL_MODE: 'Q'
_IECADR: %QW49
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '11'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 2'
_CHANNEL_MODE: 'Q'
_IECADR: %QW50
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_Q'
_INDEX_IN_PARENT: '12'
_SYMBOLIC_NAME: ''
_COMMENT: 'Control Word 3'
_CHANNEL_MODE: 'Q'
_IECADR: %QW51
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_8_2_Channels'
_INDEX_IN_PARENT: '6'
_MODULE_NAME: '0750-0483 2 AI 0-30V DC Differential Measurement Input'
_NODE_ID: 5
_IECIN: %IB216
_IECOUT: %QB216
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'Ch_1 Input word'
_CHANNEL_MODE: 'I'
_IECADR: %IW60
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'WORDOnW_I'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'Ch_2 Input word'
_CHANNEL_MODE: 'I'
_IECADR: %IW61
_END_CHANNEL
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'Type_10_2_Channels'
_INDEX_IN_PARENT: '7'
_MODULE_NAME: '0750-0513/0000-0001 2 DO 250V AC 2.0A Rel 2NO (PotFree)'
_NODE_ID: 6
_IECIN: %IB124
_IECOUT: %QB120
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_CHANNEL
_SECTION_NAME: 'BOOLOnX_Q'
_INDEX_IN_PARENT: '1'
_SYMBOLIC_NAME: ''
_COMMENT: 'Ch_1 Digital output'
_CHANNEL_MODE: 'Q'
_IECADR: %QX60.0
_END_CHANNEL

_CHANNEL
_SECTION_NAME: 'BOOLOnX_Q'
_INDEX_IN_PARENT: '2'
_SYMBOLIC_NAME: ''
_COMMENT: 'Ch_2 Digital output'
_CHANNEL_MODE: 'Q'
_IECADR: %QX60.1
_END_CHANNEL
_END_MODULE
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'PFC200MODBUS'
_INDEX_IN_PARENT: '2'
_MODULE_NAME: 'Modbus variables'
_NODE_ID: 1
_IECIN: %IB0
_IECOUT: %QB0
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''

_PARAMETER
_PARAM 2010330101: 0, '1'
_PARAM 2010330102: 0, '1'
_PARAM 2010330201: 0, '1'
_PARAM 2010330202: 0, '502'
_PARAM 2010330203: 0, '600'
_PARAM 2010330301: 0, '1'
_PARAM 2010330302: 0, '502'
_PARAM 2010330401: 0, '0'
_PARAM 2010330402: 0, '1'
_PARAM 2010330403: 0, '5000'
_PARAM 2010330404: 0, '0'
_PARAM 2010330405: 0, '115200'
_PARAM 2010330406: 0, '1'
_PARAM 2010330407: 0, '1'
_PARAM 2010330408: 0, '0'
_PARAM 2010330409: 0, '0'
_END_PARAMETER
_END_MODULE

_MODULE: '3S'
_SECTION_NAME: 'MB_MASTER'
_INDEX_IN_PARENT: '3'
_MODULE_NAME: 'Modbus-Master'
_NODE_ID: 2
_IECIN: %IB0
_IECOUT: %QB0
_IECDIAG: %MB0
_DOWNLOAD: 1
_EXCLUDEFROMAUTOADR: 0
_COMMENT: ''
_END_MODULE
_END_MODULE
PLC_END


RESOURCE

TASK MYSQL_Logging (PRIORITY := 29, INTERVAL := T#1s0ms);
Main_logger();
{Additional_info : 1,0,60000,0,1,4294967295}
END_TASK

TASK MB_RTU_MASTER_TASK (PRIORITY := 30, INTERVAL := T#5ms);
MBCFG_ModbusSlave();
{Additional_info : 1,0,0,0,1,4294967295}
END_TASK
{event_task : 'start','Called when program starts','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,1,11952}
{event_task : 'stop','Called when program stops','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,2,11952}
{event_task : 'before_reset','Called before reset takes place','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,3,11952}
{event_task : 'after_reset','Called after reset took place','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,4,11952}
{event_task : 'shutdown','Called before shutdown is performed','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,5,11952}
{event_task : 'excpt_watchdog','Software watchdog OF IEC-task expired','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,7,11952}
{event_task : 'excpt_access_violation','Access violation','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,12,11952}
{event_task : 'excpt_dividebyzero','Division BY zero','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,18,11952}
{event_task : 'after_reading_inputs','Called after reading of inputs','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,28,11952}
{event_task : 'before_writing_outputs','Called before writing of outputs','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,29,11952}
{event_task : 'debug_loop','Debug loop at breakpoint','','FUNCTION systemevent: DWORD$R$NVAR_INPUT$R$N  dwEvent: DWORD;$R$N  dwFilter: DWORD;$R$N  dwOwner: DWORD;$R$NEND_VAR$R$N'}{event_task_info : 0,31,11952}
{event_task : 'online_change','Is called after CodeInit() at Online-Change','','FUNCTION systemevent: DWORD VAR_INPUT dwEvent: DWORD; dwFilter: DWORD; dwOwner: DWORD; END_VAR '}{event_task_info : 0,33,11952}
{event_task : 'before_download','Is called before the Download starts','','FUNCTION systemevent: DWORD VAR_INPUT dwEvent: DWORD; dwFilter: DWORD; dwOwner: DWORD; END_VAR '}{event_task_info : 0,34,11952}

END_RESOURCE


_WORKSPACE
_GLOBALVISUALSETTINGS
_VISUALSETTINGSFLAGS : 0,0,0,0
_VISUALSETTINGSFLAGS : '','',''
_VISUALSETTINGSDYNTEXTFILECOUNT : 0
_VISUALBITMAPLISTCOUNT : 0
_END_GLOBALVISUALSETTINGS
_END_WORKSPACE
